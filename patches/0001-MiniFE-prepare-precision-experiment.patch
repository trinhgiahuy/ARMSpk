From 22c0259ffc04d1fd2aeacaed68b57cbc660ade01 Mon Sep 17 00:00:00 2001
From: Jens Domke <domke.j.aa@m.titech.ac.jp>
Date: Fri, 23 Feb 2018 13:57:15 +0900
Subject: [PATCH 1/1] MiniFE: prepare precision experiment

Signed-off-by: Jens Domke <domke.j.aa@m.titech.ac.jp>
---
 mkl/src/Makefile              |  4 ++--
 mkl/src/driver.hpp            | 13 +++++++++++++
 mkl/src/main.cpp              |  8 ++++++++
 openmp-opt-knl/src/Makefile   |  6 +++---
 openmp-opt-knl/src/driver.hpp | 13 +++++++++++++
 openmp-opt-knl/src/main.cpp   |  8 ++++++++
 openmp-opt/src/Makefile       |  8 ++++----
 openmp-opt/src/driver.hpp     | 13 +++++++++++++
 openmp-opt/src/main.cpp       |  8 ++++++++
 9 files changed, 72 insertions(+), 9 deletions(-)

diff --git a/mkl/src/Makefile b/mkl/src/Makefile
index d81bbcf..20a79fd 100644
--- a/mkl/src/Makefile
+++ b/mkl/src/Makefile
@@ -10,7 +10,7 @@ MINIFE_MATRIX_TYPE = -DMINIFE_CSR_MATRIX
 
 #-----------------------------------------------------------------------
 
-CFLAGS = -O3 -mkl -DMINIFE_MKL_DOUBLE -fopenmp -DUSE_MKL_DAXPBY -mavx
+CFLAGS = -O3 -ipo -xHost -I${ADVISOR_2018_DIR}/include -mkl -DMINIFE_MKL_DOUBLE -fopenmp -DUSE_MKL_DAXPBY -mavx
 CXXFLAGS = $(CFLAGS)
 
 # For debugging, the macro MINIFE_DEBUG will cause miniFE to dump a log file
@@ -22,7 +22,7 @@ CXXFLAGS = $(CFLAGS)
 CPPFLAGS = -I. -I../utils -I../fem $(MINIFE_TYPES) $(MINIFE_MATRIX_TYPE) -DHAVE_MPI -DMPICH_IGNORE_CXX_SEEK
 
 LDFLAGS=
-LIBS=
+LIBS=-L${ADVISOR_2018_DIR}/lib64 -littnotify
 
 # The MPICH_IGNORE_CXX_SEEK macro is required for some mpich versions,
 # such as the one on my cygwin machine.
diff --git a/mkl/src/driver.hpp b/mkl/src/driver.hpp
index 6c0f0f0..1cbf17b 100644
--- a/mkl/src/driver.hpp
+++ b/mkl/src/driver.hpp
@@ -88,6 +88,12 @@
   }                                 \
 }
 
+#include <ittnotify.h>
+#include <signal.h>
+#include <unistd.h>
+#define STARTSDE {if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")),SIGUSR1); __itt_resume(); __SSC_MARK(0x111);}
+#define STOPSDE {__SSC_MARK(0x222); __itt_pause(); if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")), SIGUSR1);}
+
 //This program assembles finite-element matrices into a global matrix and
 //vector, then solves the linear-system using Conjugate Gradients.
 //Each finite-element is a hexahedron with 8 vertex-nodes.
@@ -125,6 +131,8 @@ int
 driver(const Box& global_box, Box& my_box,
        Parameters& params, YAML_Doc& ydoc)
 {
+double mkrts, mkrte; // my kernel run-time
+
   int global_nx = global_box[0][1];
   int global_ny = global_box[1][1];
   int global_nz = global_box[2][1];
@@ -275,6 +283,8 @@ driver(const Box& global_box, Box& my_box,
   if (myproc==0) {
     std::cout << "Starting CG solver ... " << std::endl;
   }
+mkrts = MPI_Wtime();
+STARTSDE;
 
   if (matvec_with_comm_overlap) {
 #ifdef MINIFE_CSR_MATRIX
@@ -305,6 +315,9 @@ driver(const Box& global_box, Box& my_box,
       verify_result = verify_solution(mesh, x, tolerance, verify_whole_domain);
     }
   }
+STOPSDE;
+mkrte = MPI_Wtime();
+if (myproc == 0) printf("Walltime of the main kernel: %.6lf sec\n", mkrte - mkrts);
 
 #ifdef MINIFE_DEBUG
   write_vector("x.vec", x);
diff --git a/mkl/src/main.cpp b/mkl/src/main.cpp
index 16e27e1..a80e5be 100644
--- a/mkl/src/main.cpp
+++ b/mkl/src/main.cpp
@@ -65,6 +65,12 @@
 #define MINIFE_GLOBAL_ORDINAL int
 #endif
 
+#include <ittnotify.h>
+#include <signal.h>
+#include <unistd.h>
+#define STARTSDE {if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")),SIGUSR1); __itt_resume(); __SSC_MARK(0x111);}
+#define STOPSDE {__SSC_MARK(0x222); __itt_pause(); if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")), SIGUSR1);}
+
 // ************************************************************************
 
 void add_params_to_yaml(YAML_Doc& doc, miniFE::Parameters& params);
@@ -97,6 +103,7 @@ int main(int argc, char** argv) {
 
   int numprocs = 1, myproc = 0;
   miniFE::initialize_mpi(argc, argv, numprocs, myproc);
+STOPSDE;
 
   miniFE::timer_type start_time = miniFE::mytimer();
 
@@ -150,6 +157,7 @@ int main(int argc, char** argv) {
 
   miniFE::finalize_mpi();
 
+STARTSDE;
   return return_code;
 }
 
diff --git a/openmp-opt-knl/src/Makefile b/openmp-opt-knl/src/Makefile
index 629af96..a406c58 100644
--- a/openmp-opt-knl/src/Makefile
+++ b/openmp-opt-knl/src/Makefile
@@ -12,17 +12,17 @@ MINIFE_MATRIX_TYPE = -DMINIFE_CSR_MATRIX
 
 #-----------------------------------------------------------------------
 
-CFLAGS = -O3 -fopenmp -xMIC-AVX512
+CFLAGS = -O3 -ipo -xMIC-AVX512 -I${ADVISOR_2018_DIR}/include -fopenmp
 
 CXXFLAGS = $(CFLAGS) 
 
 CPPFLAGS = -I. -I../utils -I../fem $(MINIFE_TYPES) \
 	$(MINIFE_MATRIX_TYPE) \
 	-DMINIFE_RESTRICT=__restrict__ \
-	-DHAVE_MPI -DMPICH_IGNORE_CXX_SEEK
+	-DHAVE_MPI
 
 LDFLAGS=$(CFLAGS)
-LIBS=
+LIBS=-L${ADVISOR_2018_DIR}/lib64 -littnotify
 
 # The MPICH_IGNORE_CXX_SEEK macro is required for some mpich versions,
 # such as the one on my cygwin machine.
diff --git a/openmp-opt-knl/src/driver.hpp b/openmp-opt-knl/src/driver.hpp
index b24bdac..6eae828 100644
--- a/openmp-opt-knl/src/driver.hpp
+++ b/openmp-opt-knl/src/driver.hpp
@@ -87,6 +87,12 @@
   }                                 \
 }
 
+#include <ittnotify.h>
+#include <signal.h>
+#include <unistd.h>
+#define STARTSDE {if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")),SIGUSR1); __itt_resume(); __SSC_MARK(0x111);}
+#define STOPSDE {__SSC_MARK(0x222); __itt_pause(); if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")), SIGUSR1);}
+
 //This program assembles finite-element matrices into a global matrix and
 //vector, then solves the linear-system using Conjugate Gradients.
 //Each finite-element is a hexahedron with 8 vertex-nodes.
@@ -124,6 +130,8 @@ int
 driver(const Box& global_box, Box& my_box,
        Parameters& params, YAML_Doc& ydoc)
 {
+double mkrts, mkrte; // my kernel run-time
+
   int global_nx = global_box[0][1];
   int global_ny = global_box[1][1];
   int global_nz = global_box[2][1];
@@ -275,6 +283,8 @@ driver(const Box& global_box, Box& my_box,
     std::cout << "Starting CG solver ... " << std::endl;
   }
 
+mkrts = MPI_Wtime();
+STARTSDE;
   if (matvec_with_comm_overlap) {
 #ifdef MINIFE_CSR_MATRIX
     rearrange_matrix_local_external(A);
@@ -304,6 +314,9 @@ driver(const Box& global_box, Box& my_box,
       verify_result = verify_solution(mesh, x, tolerance, verify_whole_domain);
     }
   }
+STOPSDE;
+mkrte = MPI_Wtime();
+if (myproc == 0) printf("Walltime of the main kernel: %.6lf sec\n", mkrte - mkrts);
 
 #ifdef MINIFE_DEBUG
   write_vector("x.vec", x);
diff --git a/openmp-opt-knl/src/main.cpp b/openmp-opt-knl/src/main.cpp
index 290e661..13271dd 100644
--- a/openmp-opt-knl/src/main.cpp
+++ b/openmp-opt-knl/src/main.cpp
@@ -69,6 +69,12 @@
 #define MINIFE_GLOBAL_ORDINAL int
 #endif
 
+#include <ittnotify.h>
+#include <signal.h>
+#include <unistd.h>
+#define STARTSDE {if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")),SIGUSR1); __itt_resume(); __SSC_MARK(0x111);}
+#define STOPSDE {__SSC_MARK(0x222); __itt_pause(); if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")), SIGUSR1);}
+
 // ************************************************************************
 
 void add_params_to_yaml(YAML_Doc& doc, miniFE::Parameters& params);
@@ -88,6 +94,7 @@ int main(int argc, char** argv) {
 
   int numprocs = 1, myproc = 0;
   miniFE::initialize_mpi(argc, argv, numprocs, myproc);
+STOPSDE;
 
   miniFE::timer_type start_time = miniFE::mytimer();
 
@@ -184,6 +191,7 @@ int main(int argc, char** argv) {
 
   miniFE::finalize_mpi();
 
+STARTSDE;
   return return_code;
 }
 
diff --git a/openmp-opt/src/Makefile b/openmp-opt/src/Makefile
index bd271ec..c118822 100644
--- a/openmp-opt/src/Makefile
+++ b/openmp-opt/src/Makefile
@@ -12,17 +12,17 @@ MINIFE_MATRIX_TYPE = -DMINIFE_CSR_MATRIX
 
 #-----------------------------------------------------------------------
 
-CFLAGS = -O3 -fopenmp -mavx
+CFLAGS = -O3 -ipo -xHost -I${ADVISOR_2018_DIR}/include -fopenmp -mavx
 
-CXXFLAGS = $(CFLAGS) 
+CXXFLAGS = $(CFLAGS)
 
 CPPFLAGS = -I. -I../utils -I../fem $(MINIFE_TYPES) \
 	$(MINIFE_MATRIX_TYPE) \
 	-DMINIFE_RESTRICT=__restrict__ \
-	-DHAVE_MPI -DMPICH_IGNORE_CXX_SEEK
+	-DHAVE_MPI
 
 LDFLAGS=$(CFLAGS)
-LIBS=
+LIBS=-L${ADVISOR_2018_DIR}/lib64 -littnotify
 
 # The MPICH_IGNORE_CXX_SEEK macro is required for some mpich versions,
 # such as the one on my cygwin machine.
diff --git a/openmp-opt/src/driver.hpp b/openmp-opt/src/driver.hpp
index b38887f..a1bfd5b 100644
--- a/openmp-opt/src/driver.hpp
+++ b/openmp-opt/src/driver.hpp
@@ -87,6 +87,12 @@
   }                                 \
 }
 
+#include <ittnotify.h>
+#include <signal.h>
+#include <unistd.h>
+#define STARTSDE {if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")),SIGUSR1); __itt_resume(); __SSC_MARK(0x111);}
+#define STOPSDE {__SSC_MARK(0x222); __itt_pause(); if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")), SIGUSR1);}
+
 //This program assembles finite-element matrices into a global matrix and
 //vector, then solves the linear-system using Conjugate Gradients.
 //Each finite-element is a hexahedron with 8 vertex-nodes.
@@ -124,6 +130,8 @@ int
 driver(const Box& global_box, Box& my_box,
        Parameters& params, YAML_Doc& ydoc)
 {
+double mkrts, mkrte; // my kernel run-time
+
   int global_nx = global_box[0][1];
   int global_ny = global_box[1][1];
   int global_nz = global_box[2][1];
@@ -275,6 +283,8 @@ driver(const Box& global_box, Box& my_box,
     std::cout << "Starting CG solver ... " << std::endl;
   }
 
+mkrts = MPI_Wtime();
+STARTSDE;
   if (matvec_with_comm_overlap) {
 #ifdef MINIFE_CSR_MATRIX
     rearrange_matrix_local_external(A);
@@ -304,6 +314,9 @@ driver(const Box& global_box, Box& my_box,
       verify_result = verify_solution(mesh, x, tolerance, verify_whole_domain);
     }
   }
+STOPSDE;
+mkrte = MPI_Wtime();
+if (myproc == 0) printf("Walltime of the main kernel: %.6lf sec\n", mkrte - mkrts);
 
 #ifdef MINIFE_DEBUG
   write_vector("x.vec", x);
diff --git a/openmp-opt/src/main.cpp b/openmp-opt/src/main.cpp
index 7983fc1..a1b4b5c 100644
--- a/openmp-opt/src/main.cpp
+++ b/openmp-opt/src/main.cpp
@@ -69,6 +69,12 @@
 #define MINIFE_GLOBAL_ORDINAL int
 #endif
 
+#include <ittnotify.h>
+#include <signal.h>
+#include <unistd.h>
+#define STARTSDE {if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")),SIGUSR1); __itt_resume(); __SSC_MARK(0x111);}
+#define STOPSDE {__SSC_MARK(0x222); __itt_pause(); if(!myproc && getenv("PCMPID")) kill(atoi(getenv("PCMPID")), SIGUSR1);}
+
 // ************************************************************************
 
 void add_params_to_yaml(YAML_Doc& doc, miniFE::Parameters& params);
@@ -88,6 +94,7 @@ int main(int argc, char** argv) {
 
   int numprocs = 1, myproc = 0;
   miniFE::initialize_mpi(argc, argv, numprocs, myproc);
+STOPSDE;
 
   miniFE::timer_type start_time = miniFE::mytimer();
 
@@ -185,6 +192,7 @@ int main(int argc, char** argv) {
 
   miniFE::finalize_mpi();
 
+STARTSDE;
   return return_code;
 }
 
-- 
1.8.3.1

