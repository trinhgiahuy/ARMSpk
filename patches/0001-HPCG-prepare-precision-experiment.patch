From 7a1259fe45c455cf4a2d56eee07ce00a10399ef8 Mon Sep 17 00:00:00 2001
From: Jens Domke <domke.j.aa@m.titech.ac.jp>
Date: Thu, 1 Mar 2018 10:49:33 +0900
Subject: [PATCH] HPCG: prepare precision experiment

Signed-off-by: Jens Domke <domke.j.aa@m.titech.ac.jp>
---
 Makefile                        | 204 ++++++++++++++--
 Makefile.ext                    | 107 ++++----
 bin/hpcg.dat                    |   2 +-
 setup/Make.IMPI_IOMP_AVX2       | 151 ++++++++++++
 setup/Make.IMPI_IOMP_KNL        | 152 ++++++++++++
 src/.cproject                   |  49 ----
 src/.project                    |  27 ---
 src/CG.cpp                      | 247 ++++++++++++++-----
 src/CG.hpp                      |  17 ++
 src/CGData.hpp                  |  13 +
 src/CG_ref.cpp                  |  13 +
 src/CG_ref.hpp                  |  13 +
 src/CheckAspectRatio.cpp        |  14 ++
 src/CheckAspectRatio.hpp        |  13 +
 src/CheckProblem.cpp            |  38 ++-
 src/CheckProblem.hpp            |  15 +-
 src/ComputeDotProduct.cpp       |  13 +
 src/ComputeDotProduct.hpp       |  13 +
 src/ComputeDotProduct_ref.cpp   |  13 +
 src/ComputeDotProduct_ref.hpp   |  13 +
 src/ComputeMG.cpp               |  81 ++++++-
 src/ComputeMG.hpp               |  14 ++
 src/ComputeMG_ref.cpp           |  13 +
 src/ComputeMG_ref.hpp           |  13 +
 src/ComputeOptimalShapeXYZ.cpp  |  13 +
 src/ComputeOptimalShapeXYZ.hpp  |  13 +
 src/ComputeProlongation_ref.cpp |  14 ++
 src/ComputeProlongation_ref.hpp |  13 +
 src/ComputeResidual.cpp         |  13 +
 src/ComputeResidual.hpp         |  13 +
 src/ComputeRestriction_ref.cpp  |  14 ++
 src/ComputeRestriction_ref.hpp  |  13 +
 src/ComputeSPMV.cpp             |  97 +++++++-
 src/ComputeSPMV.hpp             |  24 +-
 src/ComputeSPMV_ref.cpp         |  13 +
 src/ComputeSPMV_ref.hpp         |  13 +
 src/ComputeSYMGS.cpp            | 145 ++++++++++-
 src/ComputeSYMGS.hpp            |  16 ++
 src/ComputeSYMGS_ref.cpp        |  13 +
 src/ComputeSYMGS_ref.hpp        |  13 +
 src/ComputeWAXPBY.cpp           |  13 +
 src/ComputeWAXPBY.hpp           |  13 +
 src/ComputeWAXPBY_ref.cpp       |  24 +-
 src/ComputeWAXPBY_ref.hpp       |  13 +
 src/ExchangeHalo.cpp            |  94 +++-----
 src/ExchangeHalo.hpp            |  13 +
 src/GenerateCoarseProblem.cpp   |  47 ++--
 src/GenerateCoarseProblem.hpp   |  13 +
 src/GenerateGeometry.cpp        | 103 ++------
 src/GenerateGeometry.hpp        |  15 +-
 src/GenerateProblem.cpp         | 330 ++++++++++++++++++++++++-
 src/GenerateProblem.hpp         |  15 ++
 src/GenerateProblem_ref.cpp     |  58 ++---
 src/GenerateProblem_ref.hpp     |  13 +
 src/Geometry.hpp                |  75 ++----
 src/MGData.hpp                  |  13 +
 src/MixedBaseCounter.cpp        |  13 +
 src/MixedBaseCounter.hpp        |  16 +-
 src/OptimizeProblem.cpp         | 253 ++++++++++++++-----
 src/OptimizeProblem.hpp         |  19 +-
 src/OutputFile.cpp              | 135 -----------
 src/OutputFile.hpp              | 160 ------------
 src/ReadHpcgDat.cpp             |  26 +-
 src/ReadHpcgDat.hpp             |  15 +-
 src/ReportResults.cpp           | 211 ++++++++--------
 src/ReportResults.hpp           |  15 +-
 src/SetupHalo.cpp               | 242 ++++++++++++++++++-
 src/SetupHalo.hpp               |  13 +
 src/SetupHalo_ref.cpp           |  32 ++-
 src/SetupHalo_ref.hpp           |  13 +
 src/SparseMatrix.hpp            | 135 ++++++++---
 src/TestCG.cpp                  |  32 ++-
 src/TestCG.hpp                  |  13 +
 src/TestNorms.cpp               |  13 +
 src/TestNorms.hpp               |  13 +
 src/TestSymmetry.cpp            |  20 +-
 src/TestSymmetry.hpp            |  15 +-
 src/Vector.hpp                  |  25 +-
 src/WriteProblem.cpp            |  13 +
 src/WriteProblem.hpp            |  13 +
 src/YAML_Doc.cpp                |  24 +-
 src/YAML_Doc.hpp                |  17 +-
 src/YAML_Element.cpp            |  13 +
 src/YAML_Element.hpp            |  13 +
 src/finalize.cpp                |  13 +
 src/hpcg.hpp                    |  32 ++-
 src/init.cpp                    |  96 +++++---
 src/main.cpp                    | 136 +++++++----
 src/mpi_hpcg_api.hpp            | 129 ++++++++++
 src/mpi_wrappers.cpp            | 523 ++++++++++++++++++++++++++++++++++++++++
 src/mytimer.cpp                 |  13 +
 src/mytimer.hpp                 |  13 +
 92 files changed, 3928 insertions(+), 1089 deletions(-)
 create mode 100644 setup/Make.IMPI_IOMP_AVX2
 create mode 100644 setup/Make.IMPI_IOMP_KNL
 delete mode 100644 src/.cproject
 delete mode 100644 src/.project
 delete mode 100644 src/OutputFile.cpp
 delete mode 100644 src/OutputFile.hpp
 create mode 100644 src/mpi_hpcg_api.hpp
 create mode 100644 src/mpi_wrappers.cpp

diff --git a/Makefile b/Makefile
index 55f0ea6..89306c4 100644
--- a/Makefile
+++ b/Makefile
@@ -1,27 +1,197 @@
-# -*- Makefile -*-
-
-# by default, "arch" is unknown, should be specified in the command line
-arch = UNKNOWN
+#===============================================================================
+# Copyright 2005-2017 Intel Corporation All Rights Reserved.
+#
+# The source code,  information  and material  ("Material") contained  herein is
+# owned by Intel Corporation or its  suppliers or licensors,  and  title to such
+# Material remains with Intel  Corporation or its  suppliers or  licensors.  The
+# Material  contains  proprietary  information  of  Intel or  its suppliers  and
+# licensors.  The Material is protected by  worldwide copyright  laws and treaty
+# provisions.  No part  of  the  Material   may  be  used,  copied,  reproduced,
+# modified, published,  uploaded, posted, transmitted,  distributed or disclosed
+# in any way without Intel's prior express written permission.  No license under
+# any patent,  copyright or other  intellectual property rights  in the Material
+# is granted to  or  conferred  upon  you,  either   expressly,  by implication,
+# inducement,  estoppel  or  otherwise.  Any  license   under such  intellectual
+# property rights must be express and approved by Intel in writing.
+#
+# Unless otherwise agreed by Intel in writing,  you may not remove or alter this
+# notice or  any  other  notice   embedded  in  Materials  by  Intel  or Intel's
+# suppliers or licensors in any way.
+#===============================================================================
 
+arch = IMPI_IOMP_AVX2
 setup_file = setup/Make.$(arch)
+
 include $(setup_file)
 
-HPCG_DEPS = src/CG.o src/CG_ref.o src/TestCG.o src/ComputeResidual.o \
-         src/ExchangeHalo.o src/GenerateGeometry.o src/GenerateProblem.o \
-         src/GenerateProblem_ref.o src/CheckProblem.o \
-	 src/OptimizeProblem.o src/ReadHpcgDat.o src/ReportResults.o \
-	 src/SetupHalo.o src/SetupHalo_ref.o src/TestSymmetry.o src/TestNorms.o src/WriteProblem.o \
-         src/YAML_Doc.o src/YAML_Element.o src/ComputeDotProduct.o \
-         src/ComputeDotProduct_ref.o src/finalize.o src/init.o src/mytimer.o src/ComputeSPMV.o \
-         src/ComputeSPMV_ref.o src/ComputeSYMGS.o src/ComputeSYMGS_ref.o src/ComputeWAXPBY.o src/ComputeWAXPBY_ref.o \
-         src/ComputeMG_ref.o src/ComputeMG.o src/ComputeProlongation_ref.o src/ComputeRestriction_ref.o src/GenerateCoarseProblem.o \
-	 src/ComputeOptimalShapeXYZ.o src/MixedBaseCounter.o src/CheckAspectRatio.o src/OutputFile.o
+HPCG_DEPS = src/CG.o \
+	    src/CG_ref.o \
+	    src/TestCG.o \
+	    src/ComputeResidual.o \
+	    src/ExchangeHalo.o \
+	    src/GenerateGeometry.o \
+	    src/GenerateProblem.o \
+	    src/GenerateProblem_ref.o \
+	    src/CheckProblem.o \
+	    src/MixedBaseCounter.o \
+	    src/OptimizeProblem.o \
+	    src/ReadHpcgDat.o \
+	    src/ReportResults.o \
+	    src/SetupHalo.o \
+	    src/SetupHalo_ref.o \
+	    src/TestSymmetry.o \
+	    src/TestNorms.o \
+	    src/WriteProblem.o \
+	    src/YAML_Doc.o \
+	    src/YAML_Element.o \
+	    src/ComputeDotProduct.o \
+	    src/ComputeDotProduct_ref.o \
+	    src/mytimer.o \
+	    src/ComputeOptimalShapeXYZ.o \
+	    src/ComputeSPMV.o \
+	    src/ComputeSPMV_ref.o \
+	    src/ComputeSYMGS.o \
+	    src/ComputeSYMGS_ref.o \
+	    src/ComputeWAXPBY.o \
+	    src/ComputeWAXPBY_ref.o \
+	    src/ComputeMG_ref.o \
+	    src/ComputeMG.o \
+	    src/ComputeProlongation_ref.o \
+	    src/ComputeRestriction_ref.o \
+	    src/CheckAspectRatio.o \
+	    src/GenerateCoarseProblem.o \
+	    src/init.o \
+	    src/finalize.o
+
+# These header files are included in many source files, so we recompile every file if one or more of these header is modified.
+PRIMARY_HEADERS = ./src/Geometry.hpp ./src/SparseMatrix.hpp ./src/Vector.hpp ./src/CGData.hpp \
+                  ./src/MGData.hpp ./src/hpcg.hpp
+MKL_INCLUDE=./../../include
+
+all: bin/xhpcg
 
 bin/xhpcg: src/main.o $(HPCG_DEPS)
-	$(LINKER) $(LINKFLAGS) src/main.o $(HPCG_DEPS) -o bin/xhpcg $(HPCG_LIBS)
+	$(LINKER) $(LINKFLAGS) src/main.o $(HPCG_DEPS) $(HPCG_LIBS) -I$(MKL_INCLUDE) -o bin/xhpcg
 
 clean:
-	rm -f $(HPCG_DEPS) bin/xhpcg src/main.o
+	rm -f src/*.o bin/xhpcg
+
+.PHONY: all clean
+
+src/main.o: ./src/main.cpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/CG.o: ./src/CG.cpp ./src/CG.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/CG_ref.o: ./src/CG_ref.cpp ./src/CG_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/TestCG.o: ./src/TestCG.cpp ./src/TestCG.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeResidual.o: ./src/ComputeResidual.cpp ./src/ComputeResidual.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ExchangeHalo.o: ./src/ExchangeHalo.cpp ./src/ExchangeHalo.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/GenerateGeometry.o: ./src/GenerateGeometry.cpp ./src/GenerateGeometry.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/GenerateProblem.o: ./src/GenerateProblem.cpp ./src/GenerateProblem.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/GenerateProblem_ref.o: ./src/GenerateProblem_ref.cpp ./src/GenerateProblem_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/CheckProblem.o: ./src/CheckProblem.cpp ./src/CheckProblem.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/MixedBaseCounter.o: ./src/MixedBaseCounter.cpp ./src/MixedBaseCounter.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/OptimizeProblem.o: ./src/OptimizeProblem.cpp ./src/OptimizeProblem.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ReadHpcgDat.o: ./src/ReadHpcgDat.cpp ./src/ReadHpcgDat.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ReportResults.o: ./src/ReportResults.cpp ./src/ReportResults.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/SetupHalo.o: ./src/SetupHalo.cpp ./src/SetupHalo.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/SetupHalo_ref.o: ./src/SetupHalo_ref.cpp ./src/SetupHalo_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/TestSymmetry.o: ./src/TestSymmetry.cpp ./src/TestSymmetry.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/TestNorms.o: ./src/TestNorms.cpp ./src/TestNorms.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/WriteProblem.o: ./src/WriteProblem.cpp ./src/WriteProblem.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/YAML_Doc.o: ./src/YAML_Doc.cpp ./src/YAML_Doc.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/YAML_Element.o: ./src/YAML_Element.cpp ./src/YAML_Element.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeDotProduct.o: ./src/ComputeDotProduct.cpp ./src/ComputeDotProduct.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeDotProduct_ref.o: ./src/ComputeDotProduct_ref.cpp ./src/ComputeDotProduct_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/finalize.o: ./src/finalize.cpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/init.o: ./src/init.cpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/mytimer.o: ./src/mytimer.cpp ./src/mytimer.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeOptimalShapeXYZ.o: ./src/ComputeOptimalShapeXYZ.cpp ./src/ComputeOptimalShapeXYZ.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeSPMV.o: ./src/ComputeSPMV.cpp ./src/ComputeSPMV.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeSPMV_ref.o: ./src/ComputeSPMV_ref.cpp ./src/ComputeSPMV_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeSYMGS.o: ./src/ComputeSYMGS.cpp ./src/ComputeSYMGS.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeSYMGS_ref.o: ./src/ComputeSYMGS_ref.cpp ./src/ComputeSYMGS_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeWAXPBY.o: ./src/ComputeWAXPBY.cpp ./src/ComputeWAXPBY.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeWAXPBY_ref.o: ./src/ComputeWAXPBY_ref.cpp ./src/ComputeWAXPBY_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeMG_ref.o: ./src/ComputeMG_ref.cpp ./src/ComputeMG_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeMG.o: ./src/ComputeMG.cpp ./src/ComputeMG.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeProlongation_ref.o: ./src/ComputeProlongation_ref.cpp ./src/ComputeProlongation_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/ComputeRestriction_ref.o: ./src/ComputeRestriction_ref.cpp ./src/ComputeRestriction_ref.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
+
+src/GenerateCoarseProblem.o: ./src/GenerateCoarseProblem.cpp ./src/GenerateCoarseProblem.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
 
-.PHONY: clean
+src/CheckAspectRatio.o: ./src/CheckAspectRatio.cpp ./src/CheckAspectRatio.hpp $(PRIMARY_HEADERS)
+	$(CXX) -c -g $(CXXFLAGS) -I./src -I$(MKL_INCLUDE) $< -o $@
 
diff --git a/Makefile.ext b/Makefile.ext
index 6857369..32006ea 100644
--- a/Makefile.ext
+++ b/Makefile.ext
@@ -1,11 +1,29 @@
-# -*- Makefile -*-
+#===============================================================================
+# Copyright 2005-2017 Intel Corporation All Rights Reserved.
+#
+# The source code,  information  and material  ("Material") contained  herein is
+# owned by Intel Corporation or its  suppliers or licensors,  and  title to such
+# Material remains with Intel  Corporation or its  suppliers or  licensors.  The
+# Material  contains  proprietary  information  of  Intel or  its suppliers  and
+# licensors.  The Material is protected by  worldwide copyright  laws and treaty
+# provisions.  No part  of  the  Material   may  be  used,  copied,  reproduced,
+# modified, published,  uploaded, posted, transmitted,  distributed or disclosed
+# in any way without Intel's prior express written permission.  No license under
+# any patent,  copyright or other  intellectual property rights  in the Material
+# is granted to  or  conferred  upon  you,  either   expressly,  by implication,
+# inducement,  estoppel  or  otherwise.  Any  license   under such  intellectual
+# property rights must be express and approved by Intel in writing.
+#
+# Unless otherwise agreed by Intel in writing,  you may not remove or alter this
+# notice or  any  other  notice   embedded  in  Materials  by  Intel  or Intel's
+# suppliers or licensors in any way.
+#===============================================================================
 
 arch = UNKNOWN
 setup_file = setup/Make.$(arch)
 
 include $(setup_file)
 
-
 HPCG_DEPS = src/CG.o \
 	    src/CG_ref.o \
 	    src/TestCG.o \
@@ -41,7 +59,6 @@ HPCG_DEPS = src/CG.o \
 	    src/ComputeProlongation_ref.o \
 	    src/ComputeRestriction_ref.o \
 	    src/CheckAspectRatio.o \
-	    src/OutputFile.o \
 	    src/GenerateCoarseProblem.o \
 	    src/init.o \
 	    src/finalize.o
@@ -49,11 +66,12 @@ HPCG_DEPS = src/CG.o \
 # These header files are included in many source files, so we recompile every file if one or more of these header is modified.
 PRIMARY_HEADERS = HPCG_SRC_PATH/src/Geometry.hpp HPCG_SRC_PATH/src/SparseMatrix.hpp HPCG_SRC_PATH/src/Vector.hpp HPCG_SRC_PATH/src/CGData.hpp \
                   HPCG_SRC_PATH/src/MGData.hpp HPCG_SRC_PATH/src/hpcg.hpp
+MKL_INCLUDE=HPCG_SRC_PATH/../../include
 
 all: bin/xhpcg
 
 bin/xhpcg: src/main.o $(HPCG_DEPS)
-	$(LINKER) $(LINKFLAGS) src/main.o $(HPCG_DEPS) $(HPCG_LIBS) -o bin/xhpcg
+	$(LINKER) $(LINKFLAGS) src/main.o $(HPCG_DEPS) $(HPCG_LIBS) -I$(MKL_INCLUDE) -o bin/xhpcg
 
 clean:
 	rm -f src/*.o bin/xhpcg
@@ -61,122 +79,119 @@ clean:
 .PHONY: all clean
 
 src/main.o: HPCG_SRC_PATH/src/main.cpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/CG.o: HPCG_SRC_PATH/src/CG.cpp HPCG_SRC_PATH/src/CG.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/CG_ref.o: HPCG_SRC_PATH/src/CG_ref.cpp HPCG_SRC_PATH/src/CG_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/TestCG.o: HPCG_SRC_PATH/src/TestCG.cpp HPCG_SRC_PATH/src/TestCG.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeResidual.o: HPCG_SRC_PATH/src/ComputeResidual.cpp HPCG_SRC_PATH/src/ComputeResidual.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ExchangeHalo.o: HPCG_SRC_PATH/src/ExchangeHalo.cpp HPCG_SRC_PATH/src/ExchangeHalo.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/GenerateGeometry.o: HPCG_SRC_PATH/src/GenerateGeometry.cpp HPCG_SRC_PATH/src/GenerateGeometry.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/GenerateProblem.o: HPCG_SRC_PATH/src/GenerateProblem.cpp HPCG_SRC_PATH/src/GenerateProblem.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/GenerateProblem_ref.o: HPCG_SRC_PATH/src/GenerateProblem_ref.cpp HPCG_SRC_PATH/src/GenerateProblem_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/CheckProblem.o: HPCG_SRC_PATH/src/CheckProblem.cpp HPCG_SRC_PATH/src/CheckProblem.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/MixedBaseCounter.o: HPCG_SRC_PATH/src/MixedBaseCounter.cpp HPCG_SRC_PATH/src/MixedBaseCounter.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/OptimizeProblem.o: HPCG_SRC_PATH/src/OptimizeProblem.cpp HPCG_SRC_PATH/src/OptimizeProblem.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ReadHpcgDat.o: HPCG_SRC_PATH/src/ReadHpcgDat.cpp HPCG_SRC_PATH/src/ReadHpcgDat.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ReportResults.o: HPCG_SRC_PATH/src/ReportResults.cpp HPCG_SRC_PATH/src/ReportResults.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/SetupHalo.o: HPCG_SRC_PATH/src/SetupHalo.cpp HPCG_SRC_PATH/src/SetupHalo.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/SetupHalo_ref.o: HPCG_SRC_PATH/src/SetupHalo_ref.cpp HPCG_SRC_PATH/src/SetupHalo_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/TestSymmetry.o: HPCG_SRC_PATH/src/TestSymmetry.cpp HPCG_SRC_PATH/src/TestSymmetry.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/TestNorms.o: HPCG_SRC_PATH/src/TestNorms.cpp HPCG_SRC_PATH/src/TestNorms.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/WriteProblem.o: HPCG_SRC_PATH/src/WriteProblem.cpp HPCG_SRC_PATH/src/WriteProblem.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/YAML_Doc.o: HPCG_SRC_PATH/src/YAML_Doc.cpp HPCG_SRC_PATH/src/YAML_Doc.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/YAML_Element.o: HPCG_SRC_PATH/src/YAML_Element.cpp HPCG_SRC_PATH/src/YAML_Element.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeDotProduct.o: HPCG_SRC_PATH/src/ComputeDotProduct.cpp HPCG_SRC_PATH/src/ComputeDotProduct.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeDotProduct_ref.o: HPCG_SRC_PATH/src/ComputeDotProduct_ref.cpp HPCG_SRC_PATH/src/ComputeDotProduct_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/finalize.o: HPCG_SRC_PATH/src/finalize.cpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/init.o: HPCG_SRC_PATH/src/init.cpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/mytimer.o: HPCG_SRC_PATH/src/mytimer.cpp HPCG_SRC_PATH/src/mytimer.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeOptimalShapeXYZ.o: HPCG_SRC_PATH/src/ComputeOptimalShapeXYZ.cpp HPCG_SRC_PATH/src/ComputeOptimalShapeXYZ.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeSPMV.o: HPCG_SRC_PATH/src/ComputeSPMV.cpp HPCG_SRC_PATH/src/ComputeSPMV.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeSPMV_ref.o: HPCG_SRC_PATH/src/ComputeSPMV_ref.cpp HPCG_SRC_PATH/src/ComputeSPMV_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeSYMGS.o: HPCG_SRC_PATH/src/ComputeSYMGS.cpp HPCG_SRC_PATH/src/ComputeSYMGS.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeSYMGS_ref.o: HPCG_SRC_PATH/src/ComputeSYMGS_ref.cpp HPCG_SRC_PATH/src/ComputeSYMGS_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeWAXPBY.o: HPCG_SRC_PATH/src/ComputeWAXPBY.cpp HPCG_SRC_PATH/src/ComputeWAXPBY.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeWAXPBY_ref.o: HPCG_SRC_PATH/src/ComputeWAXPBY_ref.cpp HPCG_SRC_PATH/src/ComputeWAXPBY_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeMG_ref.o: HPCG_SRC_PATH/src/ComputeMG_ref.cpp HPCG_SRC_PATH/src/ComputeMG_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeMG.o: HPCG_SRC_PATH/src/ComputeMG.cpp HPCG_SRC_PATH/src/ComputeMG.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeProlongation_ref.o: HPCG_SRC_PATH/src/ComputeProlongation_ref.cpp HPCG_SRC_PATH/src/ComputeProlongation_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/ComputeRestriction_ref.o: HPCG_SRC_PATH/src/ComputeRestriction_ref.cpp HPCG_SRC_PATH/src/ComputeRestriction_ref.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/GenerateCoarseProblem.o: HPCG_SRC_PATH/src/GenerateCoarseProblem.cpp HPCG_SRC_PATH/src/GenerateCoarseProblem.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
 src/CheckAspectRatio.o: HPCG_SRC_PATH/src/CheckAspectRatio.cpp HPCG_SRC_PATH/src/CheckAspectRatio.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
-
-src/OutputFile.o: HPCG_SRC_PATH/src/OutputFile.cpp HPCG_SRC_PATH/src/OutputFile.hpp $(PRIMARY_HEADERS)
-	$(CXX) -c $(CXXFLAGS) -IHPCG_SRC_PATH/src $< -o $@
+	$(CXX) -c -g $(CXXFLAGS) -IHPCG_SRC_PATH/src -I$(MKL_INCLUDE) $< -o $@
 
diff --git a/bin/hpcg.dat b/bin/hpcg.dat
index 0e4508e..e3a2a12 100644
--- a/bin/hpcg.dat
+++ b/bin/hpcg.dat
@@ -1,4 +1,4 @@
 HPCG benchmark input file
 Sandia National Laboratories; University of Tennessee, Knoxville
-104 104 104
+192 192 192
 60
diff --git a/setup/Make.IMPI_IOMP_AVX2 b/setup/Make.IMPI_IOMP_AVX2
new file mode 100644
index 0000000..9586a1c
--- /dev/null
+++ b/setup/Make.IMPI_IOMP_AVX2
@@ -0,0 +1,151 @@
+#===============================================================================
+# Copyright 2014-2017 Intel Corporation All Rights Reserved.
+#
+# The source code,  information  and material  ("Material") contained  herein is
+# owned by Intel Corporation or its  suppliers or licensors,  and  title to such
+# Material remains with Intel  Corporation or its  suppliers or  licensors.  The
+# Material  contains  proprietary  information  of  Intel or  its suppliers  and
+# licensors.  The Material is protected by  worldwide copyright  laws and treaty
+# provisions.  No part  of  the  Material   may  be  used,  copied,  reproduced,
+# modified, published,  uploaded, posted, transmitted,  distributed or disclosed
+# in any way without Intel's prior express written permission.  No license under
+# any patent,  copyright or other  intellectual property rights  in the Material
+# is granted to  or  conferred  upon  you,  either   expressly,  by implication,
+# inducement,  estoppel  or  otherwise.  Any  license   under such  intellectual
+# property rights must be express and approved by Intel in writing.
+#
+# Unless otherwise agreed by Intel in writing,  you may not remove or alter this
+# notice or  any  other  notice   embedded  in  Materials  by  Intel  or Intel's
+# suppliers or licensors in any way.
+#===============================================================================
+
+# -- High Performance Conjugate Gradient Benchmark (HPCG)
+#    HPCG - 2.1 - January 31, 2014
+#
+#    Michael A. Heroux
+#    Scalable Algorithms Group, Computing Research Center
+#    Sandia National Laboratories, Albuquerque, NM
+#
+#    Piotr Luszczek
+#    Jack Dongarra
+#    University of Tennessee, Knoxville
+#    Innovative Computing Laboratory
+#    (C) Copyright 2013 All Rights Reserved
+#
+# -- Copyright notice and Licensing terms:
+#
+# Redistribution  and  use in  source and binary forms, with or without
+# modification, are  permitted provided  that the following  conditions
+# are met:
+#
+# 1. Redistributions  of  source  code  must retain the above copyright
+# notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce  the above copyright
+# notice, this list of conditions,  and the following disclaimer in the
+# documentation and/or other materials provided with the distribution.
+#
+# 3. The name of the  University,  the name of the  Laboratory,  or the
+# names  of  its  contributors  may  not  be used to endorse or promote
+# products  derived   from   this  software  without  specific  written
+# permission.
+#
+# -- Disclaimer:
+#
+# THIS  SOFTWARE  IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  INCLUDING,  BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY
+# OR  CONTRIBUTORS  BE  LIABLE FOR ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+# SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES  (INCLUDING,  BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA OR PROFITS; OR BUSINESS INTERRUPTION)  HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT,  STRICT LIABILITY,  OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#******************************************************************************
+
+# ----------------------------------------------------------------------
+# - shell --------------------------------------------------------------
+# ----------------------------------------------------------------------
+#
+SHELL        = /bin/sh
+#
+CD           = cd
+CP           = cp
+LN_S         = ln -s -f
+MKDIR        = mkdir -p
+RM           = /bin/rm -f
+TOUCH        = touch
+#
+# ----------------------------------------------------------------------
+# - HPCG Directory Structure / HPCG library ------------------------------
+# ----------------------------------------------------------------------
+#
+TOPdir       = .
+SRCdir       = $(TOPdir)/src
+INCdir       = $(TOPdir)/src
+BINdir       = $(TOPdir)/bin
+#
+# ----------------------------------------------------------------------
+# - Message Passing library (MPI) --------------------------------------
+# ----------------------------------------------------------------------
+# MPinc tells the  C  compiler where to find the Message Passing library
+# header files,  MPlib  is defined  to be the name of  the library to be
+# used. The variable MPdir is only used for defining MPinc and MPlib.
+#
+MPdir        = 
+MPinc        = 
+MPlib        = 
+#
+#
+# ----------------------------------------------------------------------
+# - HPCG includes / libraries / specifics -------------------------------
+# ----------------------------------------------------------------------
+#
+HPCG_INCLUDES = -I$(INCdir) -I$(INCdir)/$(arch) $(MPinc) -I${ADVISOR_2018_DIR}/include
+HPCG_LIBS     = -L${ADVISOR_2018_DIR}/lib64 -littnotify
+#
+# - Compile time options -----------------------------------------------
+#
+# -DHPCG_NOMPI		Define to disable MPI
+# -DHPCG_NOOPENMP	Define to disable OPENMP
+# -DHPCG_DEBUG       	Define to enable debugging output
+# -DHPCG_DETAILED_DEBUG Define to enable very detailed debugging output
+#
+# By default HPCG will:
+#    *) Build with MPI enabled.
+#    *) Build with OpenMP enabled.
+#    *) Not generate debugging output.
+#
+HPCG_OPTS     =
+#
+# ----------------------------------------------------------------------
+#
+HPCG_DEFS     = -DMPICH_IGNORE_CXX_SEEK $(HPCG_OPTS) $(HPCG_INCLUDES)
+#
+# ----------------------------------------------------------------------
+# - Compilers / linkers - Optimization flags ---------------------------
+# ----------------------------------------------------------------------
+#
+CXX          = mpiicpc
+CXXFLAGS     = -ipo -xCORE-AVX2 -qopenmp -std=c++11 $(HPCG_DEFS)
+ifeq (yes, $(DBG))
+  CXXFLAGS  += -O0 -g -DHPCG_DEBUG
+else
+  CXXFLAGS  += -O3 -DNDEBUG
+endif
+#
+LINKER       = $(CXX)
+
+MKLROOT=../..
+MKL_LIB=$(MKLROOT)/lib/intel64
+
+LINKFLAGS    = -z relro -z now -Wl,-R'$$ORIGIN/lib/intel64' -liomp5 -L$(MKL_LIB) -liomp5 -mkl
+#
+ARCHIVER     = ar
+ARFLAGS      = r
+RANLIB       = echo
+#
+# ----------------------------------------------------------------------
+xhpcg_suff = _avx2
diff --git a/setup/Make.IMPI_IOMP_KNL b/setup/Make.IMPI_IOMP_KNL
new file mode 100644
index 0000000..9e5dc4d
--- /dev/null
+++ b/setup/Make.IMPI_IOMP_KNL
@@ -0,0 +1,152 @@
+#===============================================================================
+# Copyright 2014-2017 Intel Corporation All Rights Reserved.
+#
+# The source code,  information  and material  ("Material") contained  herein is
+# owned by Intel Corporation or its  suppliers or licensors,  and  title to such
+# Material remains with Intel  Corporation or its  suppliers or  licensors.  The
+# Material  contains  proprietary  information  of  Intel or  its suppliers  and
+# licensors.  The Material is protected by  worldwide copyright  laws and treaty
+# provisions.  No part  of  the  Material   may  be  used,  copied,  reproduced,
+# modified, published,  uploaded, posted, transmitted,  distributed or disclosed
+# in any way without Intel's prior express written permission.  No license under
+# any patent,  copyright or other  intellectual property rights  in the Material
+# is granted to  or  conferred  upon  you,  either   expressly,  by implication,
+# inducement,  estoppel  or  otherwise.  Any  license   under such  intellectual
+# property rights must be express and approved by Intel in writing.
+#
+# Unless otherwise agreed by Intel in writing,  you may not remove or alter this
+# notice or  any  other  notice   embedded  in  Materials  by  Intel  or Intel's
+# suppliers or licensors in any way.
+#===============================================================================
+
+# -- High Performance Conjugate Gradient Benchmark (HPCG)
+#    HPCG - 2.1 - January 31, 2014
+#
+#    Michael A. Heroux
+#    Scalable Algorithms Group, Computing Research Center
+#    Sandia National Laboratories, Albuquerque, NM
+#
+#    Piotr Luszczek
+#    Jack Dongarra
+#    University of Tennessee, Knoxville
+#    Innovative Computing Laboratory
+#    (C) Copyright 2013 All Rights Reserved
+#
+# -- Copyright notice and Licensing terms:
+#
+# Redistribution  and  use in  source and binary forms, with or without
+# modification, are  permitted provided  that the following  conditions
+# are met:
+#
+# 1. Redistributions  of  source  code  must retain the above copyright
+# notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce  the above copyright
+# notice, this list of conditions,  and the following disclaimer in the
+# documentation and/or other materials provided with the distribution.
+#
+# 3. The name of the  University,  the name of the  Laboratory,  or the
+# names  of  its  contributors  may  not  be used to endorse or promote
+# products  derived   from   this  software  without  specific  written
+# permission.
+#
+# -- Disclaimer:
+#
+# THIS  SOFTWARE  IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  INCLUDING,  BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY
+# OR  CONTRIBUTORS  BE  LIABLE FOR ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+# SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES  (INCLUDING,  BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA OR PROFITS; OR BUSINESS INTERRUPTION)  HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT,  STRICT LIABILITY,  OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#******************************************************************************
+
+# ----------------------------------------------------------------------
+# - shell --------------------------------------------------------------
+# ----------------------------------------------------------------------
+#
+SHELL        = /bin/sh
+#
+CD           = cd
+CP           = cp
+LN_S         = ln -s -f
+MKDIR        = mkdir -p
+RM           = /bin/rm -f
+TOUCH        = touch
+#
+# ----------------------------------------------------------------------
+# - HPCG Directory Structure / HPCG library ------------------------------
+# ----------------------------------------------------------------------
+#
+TOPdir       = .
+SRCdir       = $(TOPdir)/src
+INCdir       = $(TOPdir)/src
+BINdir       = $(TOPdir)/bin
+#
+# ----------------------------------------------------------------------
+# - Message Passing library (MPI) --------------------------------------
+# ----------------------------------------------------------------------
+# MPinc tells the  C  compiler where to find the Message Passing library
+# header files,  MPlib  is defined  to be the name of  the library to be
+# used. The variable MPdir is only used for defining MPinc and MPlib.
+#
+MPdir        = 
+MPinc        = 
+MPlib        = 
+#
+#
+# ----------------------------------------------------------------------
+# - HPCG includes / libraries / specifics -------------------------------
+# ----------------------------------------------------------------------
+#
+HPCG_INCLUDES = -I$(INCdir) -I$(INCdir)/$(arch) $(MPinc) -I${ADVISOR_2018_DIR}/include
+HPCG_LIBS     = -L${ADVISOR_2018_DIR}/lib64 -littnotify
+#
+# - Compile time options -----------------------------------------------
+#
+# -DHPCG_NOMPI		Define to disable MPI
+# -DHPCG_NOOPENMP	Define to disable OPENMP
+# -DHPCG_DEBUG       	Define to enable debugging output
+# -DHPCG_DETAILED_DEBUG Define to enable very detailed debugging output
+#
+# By default HPCG will:
+#    *) Build with MPI enabled.
+#    *) Build with OpenMP enabled.
+#    *) Not generate debugging output.
+#
+HPCG_OPTS     =
+#
+# ----------------------------------------------------------------------
+#
+HPCG_DEFS     = -DMPICH_IGNORE_CXX_SEEK $(HPCG_OPTS) $(HPCG_INCLUDES)
+#
+# ----------------------------------------------------------------------
+# - Compilers / linkers - Optimization flags ---------------------------
+# ----------------------------------------------------------------------
+#
+CXX          = mpiicpc
+CXXFLAGS     = -ipo -xMIC-AVX512 -qopt-prefetch=0 -qopenmp -std=c++11 $(HPCG_DEFS)
+ifeq (yes, $(DBG))
+  CXXFLAGS  += -O0 -g -DHPCG_DEBUG
+else
+  CXXFLAGS  += -O3 -DNDEBUG
+endif
+#
+LINKER       = $(CXX)
+
+MKLROOT=../..
+MKL_LIB=$(MKLROOT)/lib/intel64
+
+LINKFLAGS    = -z relro -z now -Wl,-R'$$ORIGIN/lib/intel64' -liomp5 -L$(MKL_LIB) -liomp5 -mkl
+
+#
+ARCHIVER     = ar
+ARFLAGS      = r
+RANLIB       = echo
+#
+# ----------------------------------------------------------------------
+xhpcg_suff = _knl
diff --git a/src/.cproject b/src/.cproject
deleted file mode 100644
index d931d66..0000000
--- a/src/.cproject
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
-	<storageModule moduleId="org.eclipse.cdt.core.settings">
-		<cconfiguration id="0.831073189">
-			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="0.831073189" moduleId="org.eclipse.cdt.core.settings" name="Default">
-				<externalSettings/>
-				<extensions>
-					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.VCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-				</extensions>
-			</storageModule>
-			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
-				<configuration buildProperties="" description="" id="0.831073189" name="Default" parent="org.eclipse.cdt.build.core.prefbase.cfg">
-					<folderInfo id="0.831073189." name="/" resourcePath="">
-						<toolChain id="org.eclipse.cdt.build.core.prefbase.toolchain.1970186644" name="No ToolChain" resourceTypeBasedDiscovery="false" superClass="org.eclipse.cdt.build.core.prefbase.toolchain">
-							<targetPlatform id="org.eclipse.cdt.build.core.prefbase.toolchain.1970186644.1213108201" name=""/>
-							<builder id="org.eclipse.cdt.build.core.settings.default.builder.818325173" keepEnvironmentInBuildfile="false" managedBuildOn="false" name="Gnu Make Builder" superClass="org.eclipse.cdt.build.core.settings.default.builder"/>
-							<tool id="org.eclipse.cdt.build.core.settings.holder.libs.277611511" name="holder for library settings" superClass="org.eclipse.cdt.build.core.settings.holder.libs"/>
-							<tool id="org.eclipse.cdt.build.core.settings.holder.1828674057" name="Assembly" superClass="org.eclipse.cdt.build.core.settings.holder">
-								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.1791847013" languageId="org.eclipse.cdt.core.assembly" languageName="Assembly" sourceContentType="org.eclipse.cdt.core.asmSource" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
-							</tool>
-							<tool id="org.eclipse.cdt.build.core.settings.holder.669619671" name="GNU C++" superClass="org.eclipse.cdt.build.core.settings.holder">
-								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.264507979" languageId="org.eclipse.cdt.core.g++" languageName="GNU C++" sourceContentType="org.eclipse.cdt.core.cxxSource,org.eclipse.cdt.core.cxxHeader" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
-							</tool>
-							<tool id="org.eclipse.cdt.build.core.settings.holder.1609672824" name="GNU C" superClass="org.eclipse.cdt.build.core.settings.holder">
-								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.1063151485" languageId="org.eclipse.cdt.core.gcc" languageName="GNU C" sourceContentType="org.eclipse.cdt.core.cSource,org.eclipse.cdt.core.cHeader" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
-							</tool>
-						</toolChain>
-					</folderInfo>
-				</configuration>
-			</storageModule>
-			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
-		</cconfiguration>
-	</storageModule>
-	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
-		<project id="HPCG.null.1345978066" name="HPCG"/>
-	</storageModule>
-	<storageModule moduleId="scannerConfiguration">
-		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
-		<scannerConfigBuildInfo instanceId="0.831073189">
-			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
-		</scannerConfigBuildInfo>
-	</storageModule>
-	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
-</cproject>
diff --git a/src/.project b/src/.project
deleted file mode 100644
index d4f345e..0000000
--- a/src/.project
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>HPCG</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
-			<triggers>clean,full,incremental,</triggers>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
-			<triggers>full,incremental,</triggers>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.cdt.core.cnature</nature>
-		<nature>org.eclipse.cdt.core.ccnature</nature>
-		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
-		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
-	</natures>
-</projectDescription>
diff --git a/src/CG.cpp b/src/CG.cpp
index 34b5f47..22f13a5 100644
--- a/src/CG.cpp
+++ b/src/CG.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -21,16 +34,21 @@
 #include <fstream>
 
 #include <cmath>
+#include <cfloat>
 
 #include "hpcg.hpp"
 
 #include "CG.hpp"
 #include "mytimer.hpp"
 #include "ComputeSPMV.hpp"
+#include "ComputeSPMV_ref.hpp"
 #include "ComputeMG.hpp"
 #include "ComputeDotProduct.hpp"
 #include "ComputeWAXPBY.hpp"
 
+#ifndef HPCG_NO_MPI
+#include "ExchangeHalo.hpp"
+#endif
 
 // Use TICK and TOCK to time a code section in MATLAB-like fashion
 #define TICK()  t0 = mytimer() //!< record current time in 't0'
@@ -60,84 +78,187 @@ int CG(const SparseMatrix & A, CGData & data, const Vector & b, Vector & x,
     const int max_iter, const double tolerance, int & niters, double & normr, double & normr0,
     double * times, bool doPreconditioning) {
 
-  double t_begin = mytimer();  // Start timing right away
-  normr = 0.0;
-  double rtz = 0.0, oldrtz = 0.0, alpha = 0.0, beta = 0.0, pAp = 0.0;
+    double rtz = 0.0, oldrtz = 0.0, alpha = 0.0, beta = 0.0, pAp = 0.0, ff = 0.0;
 
+    double t0 = 0.0, t1 = 0.0, t2 = 0.0, t3 = 0.0, t4 = 0.0, t5 = 0.0;
+    double t_begin = mytimer();  // Start timing right away
 
-  double t0 = 0.0, t1 = 0.0, t2 = 0.0, t3 = 0.0, t4 = 0.0, t5 = 0.0;
-//#ifndef HPCG_NO_MPI
-//  double t6 = 0.0;
-//#endif
-  local_int_t nrow = A.localNumberOfRows;
-  Vector & r = data.r; // Residual vector
-  Vector & z = data.z; // Preconditioned residual vector
-  Vector & p = data.p; // Direction vector (in MPI mode ncol>=nrow)
-  Vector & Ap = data.Ap;
+    MPI_Request *request = new MPI_Request();
+    normr = 0.0;
+    local_int_t nthr = A.nproc;
+    local_int_t nrow = A.localNumberOfRows;
+    Vector & r = data.r; // Residual vector
+    Vector & z = data.z; // Preconditioned residual vector
+    Vector & p = data.p; // Direction vector (in MPI mode ncol>=nrow)
+    Vector & Ap = data.Ap;
 
-  if (!doPreconditioning && A.geom->rank==0) HPCG_fout << "WARNING: PERFORMING UNPRECONDITIONED ITERATIONS" << std::endl;
+    if (!doPreconditioning && A.geom->rank==0) HPCG_fout << "WARNING: PERFORMING UNPRECONDITIONED ITERATIONS OPT" << std::endl;
 
 #ifdef HPCG_DEBUG
-  int print_freq = 1;
-  if (print_freq>50) print_freq=50;
-  if (print_freq<1)  print_freq=1;
+    int print_freq = 1;
+    if (print_freq>50) print_freq=50;
+    if (print_freq<1)  print_freq=1;
 #endif
   // p is of length ncols, copy x to p for sparse MV operation
-  CopyVector(x, p);
-  TICK(); ComputeSPMV(A, p, Ap); TOCK(t3); // Ap = A*p
-  TICK(); ComputeWAXPBY(nrow, 1.0, b, -1.0, Ap, r, A.isWaxpbyOptimized);  TOCK(t2); // r = b - Ax (x stored in p)
-  TICK(); ComputeDotProduct(nrow, r, r, normr, t4, A.isDotProductOptimized); TOCK(t1);
-  normr = sqrt(normr);
+
+    double normr_tmp = 0.0;
+
+    TICK();
+    #ifndef HPCG_NO_OPENMP
+    #pragma omp parallel for num_threads(nthr) reduction(+:normr_tmp)
+    #endif
+    for ( local_int_t i = 0; i < nrow; ++i )
+    {
+        r.values[i] = b.values[i];
+        normr_tmp += r.values [i] * r.values [i];
+    }
+    TOCK(t2);
+    TICK();
+    double global_result = 0.0;
+    MPI_Allreduce(&normr_tmp, &global_result, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
+    normr_tmp = global_result;
+    normr = sqrt(normr_tmp);
+    // Record initial residual for convergence testing
+    normr0 = normr;
+    ff = normr/normr0-tolerance;
+    TOCK(t4);
+
+    int converge_flag = 0;
+    if ( ff <= 0.0 )
+    {
+        converge_flag = 1;
+    }
+
 #ifdef HPCG_DEBUG
-  if (A.geom->rank==0) HPCG_fout << "Initial Residual = "<< normr << std::endl;
+    if (A.geom->rank==0) HPCG_fout << "Initial Residual = "<< normr << std::endl;
 #endif
+    // Start iterations
 
-  // Record initial residual for convergence testing
-  normr0 = normr;
+  for (int k=1; (k<=max_iter && ff >= DBL_EPSILON) || (converge_flag == 1 && k <= 50); k++ )
+    {
+        if (doPreconditioning)
+        {
+            TICK(); ComputeMG(A, r, z); TOCK(t5); // Apply preconditioner
+        } else
+        {
+            TICK(); CopyVector (r, z); TOCK(t5); // copy r to z (no preconditioning)
+        }
 
-  // Start iterations
+        if (k == 1) {
+            TICK();
+            normr_tmp = 0.0;
+            #ifndef HPCG_NO_OPENMP
+            #pragma omp parallel for reduction(+:normr_tmp)
+            #endif
+            for ( local_int_t i = 0; i < nrow; i++ )
+            {
+                p.values[i] = z.values[i];
+                normr_tmp += r.values[i]*z.values[i];
+            }
+            TOCK(t2);
+            TICK();
+            global_result = 0.0;
+            MPI_Allreduce(&normr_tmp, &global_result, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
+            rtz = global_result;
+            TOCK(t4);
+        } else {
+            TICK();
+            oldrtz = rtz;
+            normr_tmp = 0.0;
+            #ifndef HPCG_NO_OPENMP
+            #pragma omp parallel for reduction(+:normr_tmp)
+            #endif
+            for ( local_int_t i = 0; i < nrow; i++ )
+                normr_tmp += r.values[i]*z.values[i];
+            TOCK(t1);
+            TICK();
+            global_result = 0.0;
+            MPI_Allreduce(&normr_tmp, &global_result, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
 
-  for (int k=1; k<=max_iter && normr/normr0 > tolerance; k++ ) {
-    TICK();
-    if (doPreconditioning)
-      ComputeMG(A, r, z); // Apply preconditioner
-    else
-      CopyVector (r, z); // copy r to z (no preconditioning)
-    TOCK(t5); // Preconditioner apply time
-
-    if (k == 1) {
-      TICK(); ComputeWAXPBY(nrow, 1.0, z, 0.0, z, p, A.isWaxpbyOptimized); TOCK(t2); // Copy Mr to p
-      TICK(); ComputeDotProduct (nrow, r, z, rtz, t4, A.isDotProductOptimized); TOCK(t1); // rtz = r'*z
-    } else {
-      oldrtz = rtz;
-      TICK(); ComputeDotProduct (nrow, r, z, rtz, t4, A.isDotProductOptimized); TOCK(t1); // rtz = r'*z
-      beta = rtz/oldrtz;
-      TICK(); ComputeWAXPBY (nrow, 1.0, z, beta, p, p, A.isWaxpbyOptimized);  TOCK(t2); // p = beta*p + z
-    }
+            rtz = global_result;
+            beta = rtz/oldrtz;
+            TOCK(t4);
+            TICK();
+            #ifndef HPCG_NO_OPENMP
+            #pragma omp parallel for
+            #endif
+            for ( local_int_t i = 0; i < nrow; i++ )
+            {
+                p.values[i] = beta*p.values[i] + z.values[i];
+            }
+            TOCK(t2);
+        }
+
+        if ( A.geom->size > 1 )
+        {
+            normr_tmp = 0.0;
+            TICK(); ComputeSPMV_DOT(A, p, Ap, normr_tmp); TOCK(t3); // Ap = A*p
+            TICK();
+            global_result = 0.0;
+            MPI_Allreduce(&normr_tmp, &global_result, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
+            pAp = global_result;
+            TOCK(t4);
+        } else
+        {
+            TICK();
+            sparse_status_t status = SPARSE_STATUS_SUCCESS;
+            struct optData *optData = (struct optData *)A.optimizationData;
+            struct matrix_descr descr;
+            sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+            descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+            descr.mode = SPARSE_FILL_MODE_FULL;
+            descr.diag = SPARSE_DIAG_NON_UNIT;
+
+            status = mkl_sparse_d_dotmv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, p.values, 0.0, Ap.values, &pAp );
+            TOCK(t3);
+        }
+
+        TICK();
+        alpha = rtz/pAp;
+        normr_tmp = 0.0;
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for reduction(+:normr_tmp)
+        #endif
+        for ( local_int_t i = 0; i < nrow; i++ )
+        {
+            r.values[i] -= alpha * Ap.values[i];
+            normr_tmp += r.values[i]*r.values[i];
+        }
+        TOCK(t2);// r = r - alpha*Ap
+
+        TICK();
+        global_result = 0.0;
+        MPI_Iallreduce(&normr_tmp, &global_result, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD, (MPI_Request *)request);
 
-    TICK(); ComputeSPMV(A, p, Ap); TOCK(t3); // Ap = A*p
-    TICK(); ComputeDotProduct(nrow, p, Ap, pAp, t4, A.isDotProductOptimized); TOCK(t1); // alpha = p'*Ap
-    alpha = rtz/pAp;
-    TICK(); ComputeWAXPBY(nrow, 1.0, x, alpha, p, x, A.isWaxpbyOptimized);// x = x + alpha*p
-            ComputeWAXPBY(nrow, 1.0, r, -alpha, Ap, r, A.isWaxpbyOptimized);  TOCK(t2);// r = r - alpha*Ap
-    TICK(); ComputeDotProduct(nrow, r, r, normr, t4, A.isDotProductOptimized); TOCK(t1);
-    normr = sqrt(normr);
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+        #endif
+        for ( local_int_t i = 0; i < nrow; i++ )
+        {
+            x.values[i] += alpha *  p.values[i];
+        }
+        MPI_Wait((MPI_Request *)request, MPI_STATUS_IGNORE);
+
+        normr_tmp = global_result;
+        normr = sqrt(normr_tmp);
+        ff = normr/normr0-tolerance;
+        niters = k;
+        TOCK(t4);
 #ifdef HPCG_DEBUG
-    if (A.geom->rank==0 && (k%print_freq == 0 || k == max_iter))
-      HPCG_fout << "Iteration = "<< k << "   Scaled Residual = "<< normr/normr0 << std::endl;
+        if (A.geom->rank==0 && (k%print_freq == 0 || k == max_iter))
+            HPCG_fout << "Iteration = "<< k <<" " << tolerance <<" " << A.geom->rank << "   Scaled Residual = "<< normr/normr0 << std::endl;
 #endif
-    niters = k;
-  }
+    }
 
   // Store times
-  times[1] += t1; // dot-product time
-  times[2] += t2; // WAXPBY time
-  times[3] += t3; // SPMV time
-  times[4] += t4; // AllReduce time
-  times[5] += t5; // preconditioner apply time
-//#ifndef HPCG_NO_MPI
-//  times[6] += t6; // exchange halo time
-//#endif
-  times[0] += mytimer() - t_begin;  // Total time. All done...
-  return 0;
+    times[0] += mytimer() - t_begin;  // Total time. All done...
+    times[1] += t1; // dot-product time
+    times[2] += t2; // WAXPBY time
+    times[3] += t3; // SPMV time
+    times[4] += t4; // AllReduce time
+    times[5] += t5; // preconditioner apply time
+
+    delete (MPI_Request *)request;
+
+    return 0;
 }
diff --git a/src/CG.hpp b/src/CG.hpp
index a080dfa..a83336d 100644
--- a/src/CG.hpp
+++ b/src/CG.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -19,6 +32,10 @@
 #include "Vector.hpp"
 #include "CGData.hpp"
 
+#ifndef HPCG_NO_MPI
+#include <mpi.h>
+#endif
+
 int CG(const SparseMatrix & A, CGData & data, const Vector & b, Vector & x,
     const int max_iter, const double tolerance, int & niters, double & normr,  double & normr0,
     double * times, bool doPreconditioning);
diff --git a/src/CGData.hpp b/src/CGData.hpp
index 0a5d7bc..3143a7b 100644
--- a/src/CGData.hpp
+++ b/src/CGData.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/CG_ref.cpp b/src/CG_ref.cpp
index 25d5f4e..a2f0bed 100644
--- a/src/CG_ref.cpp
+++ b/src/CG_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/CG_ref.hpp b/src/CG_ref.hpp
index c58df0b..db1da14 100644
--- a/src/CG_ref.hpp
+++ b/src/CG_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/CheckAspectRatio.cpp b/src/CheckAspectRatio.cpp
index 852e947..34519d9 100644
--- a/src/CheckAspectRatio.cpp
+++ b/src/CheckAspectRatio.cpp
@@ -1,3 +1,17 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
+
 //@HEADER
 // ***************************************************
 //
diff --git a/src/CheckAspectRatio.hpp b/src/CheckAspectRatio.hpp
index d1ad5fa..a9894f3 100644
--- a/src/CheckAspectRatio.hpp
+++ b/src/CheckAspectRatio.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/CheckProblem.cpp b/src/CheckProblem.cpp
index 165a8ae..866304c 100644
--- a/src/CheckProblem.cpp
+++ b/src/CheckProblem.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -47,22 +60,25 @@ using std::endl;
   @see GenerateGeometry
 */
 
-void CheckProblem(SparseMatrix & A, Vector * b, Vector * x, Vector * xexact) {
+void CheckProblem(const SparseMatrix & A, Vector * b, Vector * x, Vector * xexact) {
 
   // Make local copies of geometry information.  Use global_int_t since the RHS products in the calculations
   // below may result in global range values.
   global_int_t nx = A.geom->nx;
   global_int_t ny = A.geom->ny;
   global_int_t nz = A.geom->nz;
-  global_int_t gnx = A.geom->gnx;
-  global_int_t gny = A.geom->gny;
-  global_int_t gnz = A.geom->gnz;
-  global_int_t gix0 = A.geom->gix0;
-  global_int_t giy0 = A.geom->giy0;
-  global_int_t giz0 = A.geom->giz0;
+  global_int_t npx = A.geom->npx;
+  global_int_t npy = A.geom->npy;
+  global_int_t npz = A.geom->npz;
+  global_int_t ipx = A.geom->ipx;
+  global_int_t ipy = A.geom->ipy;
+  global_int_t ipz = A.geom->ipz;
+  global_int_t gnx = nx*npx;
+  global_int_t gny = ny*npy;
+  global_int_t gnz = nz*npz;
 
   local_int_t localNumberOfRows = nx*ny*nz; // This is the size of our subblock
-  global_int_t totalNumberOfRows = gnx*gny*gnz; // Total number of grid points in mesh
+  global_int_t totalNumberOfRows = ((global_int_t) localNumberOfRows)*((global_int_t) A.geom->size); // Total number of grid points in mesh
 
   double * bv = 0;
   double * xv = 0;
@@ -77,11 +93,11 @@ void CheckProblem(SparseMatrix & A, Vector * b, Vector * x, Vector * xexact) {
   #pragma omp parallel for
 #endif
   for (local_int_t iz=0; iz<nz; iz++) {
-    global_int_t giz = giz0+iz;
+    global_int_t giz = ipz*nz+iz;
     for (local_int_t iy=0; iy<ny; iy++) {
-      global_int_t giy = giy0+iy;
+      global_int_t giy = ipy*ny+iy;
       for (local_int_t ix=0; ix<nx; ix++) {
-        global_int_t gix = gix0+ix;
+        global_int_t gix = ipx*nx+ix;
         local_int_t currentLocalRow = iz*nx*ny+iy*nx+ix;
         global_int_t currentGlobalRow = giz*gnx*gny+giy*gnx+gix;
         assert(A.localToGlobalMap[currentLocalRow] == currentGlobalRow);
diff --git a/src/CheckProblem.hpp b/src/CheckProblem.hpp
index 50cbed9..8a9105d 100644
--- a/src/CheckProblem.hpp
+++ b/src/CheckProblem.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -17,5 +30,5 @@
 #include "SparseMatrix.hpp"
 #include "Vector.hpp"
 
-void CheckProblem(SparseMatrix & A, Vector * b, Vector * x, Vector * xexact);
+void CheckProblem(const SparseMatrix & A, Vector * b, Vector * x, Vector * xexact);
 #endif // CHECKPROBLEM_HPP
diff --git a/src/ComputeDotProduct.cpp b/src/ComputeDotProduct.cpp
index 0c59d70..e08f2e8 100644
--- a/src/ComputeDotProduct.cpp
+++ b/src/ComputeDotProduct.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeDotProduct.hpp b/src/ComputeDotProduct.hpp
index 33a213c..567a166 100644
--- a/src/ComputeDotProduct.hpp
+++ b/src/ComputeDotProduct.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeDotProduct_ref.cpp b/src/ComputeDotProduct_ref.cpp
index 85bf9dc..d3170df 100644
--- a/src/ComputeDotProduct_ref.cpp
+++ b/src/ComputeDotProduct_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeDotProduct_ref.hpp b/src/ComputeDotProduct_ref.hpp
index d403614..58d979b 100644
--- a/src/ComputeDotProduct_ref.hpp
+++ b/src/ComputeDotProduct_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeMG.cpp b/src/ComputeMG.cpp
index 528ec6b..7da1c84 100644
--- a/src/ComputeMG.cpp
+++ b/src/ComputeMG.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -19,7 +32,19 @@
  */
 
 #include "ComputeMG.hpp"
-#include "ComputeMG_ref.hpp"
+#include "ComputeSYMGS.hpp"
+#include "ComputeSPMV.hpp"
+#include "ComputeRestriction_ref.hpp"
+#include "ComputeProlongation_ref.hpp"
+
+#ifndef HPCG_NO_MPI
+#include "ExchangeHalo.hpp"
+#include <mpi.h>
+#include "Geometry.hpp"
+#include <cstdlib>
+#endif
+
+int ComputeMG_ref(const SparseMatrix & A, const Vector & r, Vector & x);
 
 /*!
   @param[in] A the known system matrix
@@ -30,9 +55,55 @@
 
   @see ComputeMG_ref
 */
-int ComputeMG(const SparseMatrix  & A, const Vector & r, Vector & x) {
+int ComputeMG(const SparseMatrix  & A, const Vector & r, Vector & x)
+{
+    int ierr = 0;
+
+    if (A.mgData!=0) // Go to next coarse level if defined
+    {
+        const int numberOfPresmootherSteps = A.mgData->numberOfPresmootherSteps;
+        const int numberOfPostsmootherSteps = A.mgData->numberOfPostsmootherSteps;
+
+        if ( numberOfPresmootherSteps > 1 )
+        {
+            sparse_status_t status = SPARSE_STATUS_SUCCESS;
+            struct optData *optData = (struct optData *)A.optimizationData;
+            struct matrix_descr descr;
+            sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+            descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+            descr.mode = SPARSE_FILL_MODE_FULL;
+            descr.diag = SPARSE_DIAG_NON_UNIT;
+
+            if ( mkl_sparse_d_symgs(SPARSE_OPERATION_NON_TRANSPOSE, csrA, descr, 0.0, r.values, x.values) != SPARSE_STATUS_SUCCESS ) ierr ++;
+
+            for ( int i = 1; i < numberOfPresmootherSteps; ++i ) ierr += ComputeSYMGS(A, r, x);
+            ierr += ComputeSPMV(A, x, (*A.mgData->Axf));
+        } else
+        {
+            ierr += ComputeSYMGS_MV(A, r, x, (*A.mgData->Axf));
+        }
+
+        ierr += ComputeRestriction_ref(A, r);
+        ierr += ComputeMG(*A.Ac,*A.mgData->rc, *A.mgData->xc);
+        ierr += ComputeProlongation_ref(A, x);
+
+        for ( int i = 0; i < numberOfPostsmootherSteps; ++i ) ierr += ComputeSYMGS(A, r, x);
+
+        if ( ierr != 0 ) return 1;
+    } else
+    {
+        sparse_status_t status = SPARSE_STATUS_SUCCESS;
+        struct optData *optData = (struct optData *)A.optimizationData;
+        struct matrix_descr descr;
+        sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+        descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+        descr.mode = SPARSE_FILL_MODE_FULL;
+        descr.diag = SPARSE_DIAG_NON_UNIT;
+
+        status = mkl_sparse_d_symgs(SPARSE_OPERATION_NON_TRANSPOSE, csrA, descr, 0.0, r.values, x.values);
+
+        if ( status != SPARSE_STATUS_SUCCESS ) return 1;
+    }
 
-  // This line and the next two lines should be removed and your version of ComputeSYMGS should be used.
-  A.isMgOptimized = false;
-  return ComputeMG_ref(A, r, x);
+    return 0;
 }
diff --git a/src/ComputeMG.hpp b/src/ComputeMG.hpp
index 45f664e..3caac5f 100644
--- a/src/ComputeMG.hpp
+++ b/src/ComputeMG.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -16,6 +29,7 @@
 #define COMPUTEMG_HPP
 #include "SparseMatrix.hpp"
 #include "Vector.hpp"
+#include "mkl.h"
 
 int ComputeMG(const SparseMatrix  & A, const Vector & r, Vector & x);
 
diff --git a/src/ComputeMG_ref.cpp b/src/ComputeMG_ref.cpp
index efc6f10..13cf0e4 100644
--- a/src/ComputeMG_ref.cpp
+++ b/src/ComputeMG_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeMG_ref.hpp b/src/ComputeMG_ref.hpp
index 97028b5..4084a2c 100644
--- a/src/ComputeMG_ref.hpp
+++ b/src/ComputeMG_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeOptimalShapeXYZ.cpp b/src/ComputeOptimalShapeXYZ.cpp
index fad6678..c94ca7d 100644
--- a/src/ComputeOptimalShapeXYZ.cpp
+++ b/src/ComputeOptimalShapeXYZ.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 #include <cmath>
 #include <cstdlib>
diff --git a/src/ComputeOptimalShapeXYZ.hpp b/src/ComputeOptimalShapeXYZ.hpp
index 03d1dc5..4215dc0 100644
--- a/src/ComputeOptimalShapeXYZ.hpp
+++ b/src/ComputeOptimalShapeXYZ.hpp
@@ -1,2 +1,15 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 void ComputeOptimalShapeXYZ(int xyz, int & x, int & y, int & z);
diff --git a/src/ComputeProlongation_ref.cpp b/src/ComputeProlongation_ref.cpp
index ac9df50..d8565dc 100644
--- a/src/ComputeProlongation_ref.cpp
+++ b/src/ComputeProlongation_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -46,6 +59,7 @@ int ComputeProlongation_ref(const SparseMatrix & Af, Vector & xf) {
 #pragma omp parallel for
 #endif
 // TODO: Somehow note that this loop can be safely vectorized since f2c has no repeated indices
+#pragma ivdep
   for (local_int_t i=0; i<nc; ++i) xfv[f2c[i]] += xcv[i]; // This loop is safe to vectorize
 
   return 0;
diff --git a/src/ComputeProlongation_ref.hpp b/src/ComputeProlongation_ref.hpp
index 5e437f2..ded62af 100644
--- a/src/ComputeProlongation_ref.hpp
+++ b/src/ComputeProlongation_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeResidual.cpp b/src/ComputeResidual.cpp
index afc57c6..7e1adeb 100644
--- a/src/ComputeResidual.cpp
+++ b/src/ComputeResidual.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeResidual.hpp b/src/ComputeResidual.hpp
index 524fee0..3164d47 100644
--- a/src/ComputeResidual.hpp
+++ b/src/ComputeResidual.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeRestriction_ref.cpp b/src/ComputeRestriction_ref.cpp
index 23be02a..d36b970 100644
--- a/src/ComputeRestriction_ref.cpp
+++ b/src/ComputeRestriction_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -48,6 +61,7 @@ int ComputeRestriction_ref(const SparseMatrix & A, const Vector & rf) {
 #ifndef HPCG_NO_OPENMP
 #pragma omp parallel for
 #endif
+#pragma ivdep
   for (local_int_t i=0; i<nc; ++i) rcv[i] = rfv[f2c[i]] - Axfv[f2c[i]];
 
   return 0;
diff --git a/src/ComputeRestriction_ref.hpp b/src/ComputeRestriction_ref.hpp
index cd78948..c92a32f 100644
--- a/src/ComputeRestriction_ref.hpp
+++ b/src/ComputeRestriction_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeSPMV.cpp b/src/ComputeSPMV.cpp
index d039c1c..ff64472 100644
--- a/src/ComputeSPMV.cpp
+++ b/src/ComputeSPMV.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -21,6 +34,13 @@
 #include "ComputeSPMV.hpp"
 #include "ComputeSPMV_ref.hpp"
 
+#ifndef HPCG_NO_MPI
+#include "ExchangeHalo.hpp"
+
+#include <mpi.h>
+#include "Geometry.hpp"
+#include <cstdlib>
+#endif
 /*!
   Routine to compute sparse matrix vector product y = Ax where:
   Precondition: First call exchange_externals to get off-processor values of x
@@ -37,9 +57,78 @@
 
   @see ComputeSPMV_ref
 */
-int ComputeSPMV( const SparseMatrix & A, Vector & x, Vector & y) {
 
-  // This line and the next two lines should be removed and your version of ComputeSPMV should be used.
-  A.isSpmvOptimized = false;
-  return ComputeSPMV_ref(A, x, y);
+int ComputeSPMV( const SparseMatrix & A, Vector & x, Vector & y)
+{
+    sparse_status_t status = SPARSE_STATUS_SUCCESS;
+    struct optData *optData = (struct optData *)A.optimizationData;
+    struct matrix_descr descr;
+    sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+    sparse_matrix_t csrB = (sparse_matrix_t)optData->csrB;
+    descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+    descr.mode = SPARSE_FILL_MODE_FULL;
+    descr.diag = SPARSE_DIAG_NON_UNIT;
+
+    #ifndef HPCG_NO_MPI
+    ExchangeHalo(A,x);
+    #endif
+
+    status = mkl_sparse_d_mv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, x.values, 0.0, y.values );
+
+    if ( A.geom->size > 1 )
+    {
+        descr.type = SPARSE_MATRIX_TYPE_GENERAL;
+        status = mkl_sparse_d_mv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrB, descr, x.values, 0.0, optData->dtmp );
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+        #endif
+        #pragma ivdep
+        for (local_int_t i=0; i<optData->nrow_b; i++)
+        {
+            const MKL_INT ind = optData->bmap[i];
+            y.values[ind] += optData->dtmp[i];
+        }
+    }
+
+    return 0;
+}
+
+int ComputeSPMV_DOT( const SparseMatrix & A, Vector & x, Vector & y, double & pAp)
+{
+    sparse_status_t status = SPARSE_STATUS_SUCCESS;
+    struct optData *optData = (struct optData *)A.optimizationData;
+    struct matrix_descr descr;
+    sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+    sparse_matrix_t csrB = (sparse_matrix_t)optData->csrB;
+    descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+    descr.mode = SPARSE_FILL_MODE_FULL;
+    descr.diag = SPARSE_DIAG_NON_UNIT;
+
+    #ifndef HPCG_NO_MPI
+    ExchangeHalo(A,x);
+    #endif
+
+    status = mkl_sparse_d_dotmv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, x.values, 0.0, y.values, &pAp );
+
+    if ( A.geom->size > 1 )
+    {
+        descr.type = SPARSE_MATRIX_TYPE_GENERAL;
+        status = mkl_sparse_d_mv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrB, descr, x.values, 0.0, optData->dtmp );
+        double pAp_loc = 0, pAp_red = 0;
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for reduction(+:pAp_loc,pAp_red)
+        #endif
+        #pragma ivdep
+        for (local_int_t i=0; i<optData->nrow_b; i++)
+        {
+            const MKL_INT ind = optData->bmap[i];
+            const double x_cur = x.values[ind];
+            pAp_red += y.values[ind]*x_cur;
+            y.values[ind] += optData->dtmp[i];
+            pAp_loc += y.values[ind]*x_cur;
+        }
+        pAp += (pAp_loc - pAp_red);
+    }
+
+    return 0;
 }
diff --git a/src/ComputeSPMV.hpp b/src/ComputeSPMV.hpp
index 5663ab4..1ab1844 100644
--- a/src/ComputeSPMV.hpp
+++ b/src/ComputeSPMV.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -17,6 +30,15 @@
 #include "Vector.hpp"
 #include "SparseMatrix.hpp"
 
-int ComputeSPMV( const SparseMatrix & A, Vector & x, Vector & y);
+#include "mkl_spblas.h"
+#include "mkl_service.h"
+#include "stdio.h"
+
+#ifndef HPCG_NO_OPENMP
+#include <omp.h>
+#endif
+
+int ComputeSPMV( const SparseMatrix & A, Vector & x, Vector & y );
+int ComputeSPMV_DOT( const SparseMatrix & A, Vector & x, Vector & y, double & pAp);
 
 #endif  // COMPUTESPMV_HPP
diff --git a/src/ComputeSPMV_ref.cpp b/src/ComputeSPMV_ref.cpp
index 7286be1..b091205 100644
--- a/src/ComputeSPMV_ref.cpp
+++ b/src/ComputeSPMV_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeSPMV_ref.hpp b/src/ComputeSPMV_ref.hpp
index c2f8821..2eb3c9d 100644
--- a/src/ComputeSPMV_ref.hpp
+++ b/src/ComputeSPMV_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeSYMGS.cpp b/src/ComputeSYMGS.cpp
index 4034ba3..80339d1 100644
--- a/src/ComputeSYMGS.cpp
+++ b/src/ComputeSYMGS.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -20,9 +33,20 @@
 
 #include "ComputeSYMGS.hpp"
 #include "ComputeSYMGS_ref.hpp"
+#ifndef HPCG_NO_OPENMP
+#include <omp.h>
+#endif
 
+#ifndef HPCG_NO_MPI
+#include "ExchangeHalo.hpp"
+#include <mpi.h>
+#include "Geometry.hpp"
+#include <cstdlib>
+#endif
+
+#include "mkl.h"
 /*!
-  Routine to compute one step of symmetric Gauss-Seidel:
+  Routine to one step of symmetrix Gauss-Seidel:
 
   Assumption about the structure of matrix A:
   - Each row 'i' of the matrix has nonzero diagonal value whose address is matrixDiagonal[i]
@@ -37,9 +61,9 @@
   - We then perform one back sweep.
        - For simplicity we include the diagonal contribution in the for-j loop, then correct the sum after
 
-  @param[in] A the known system matrix
-  @param[in] r the input vector
-  @param[inout] x On entry, x should contain relevant values, on exit x contains the result of one symmetric GS sweep with r as the RHS.
+  @param[in]  A the known system matrix
+  @param[in]  x the input vector
+  @param[out] y On exit contains the result of one symmetric GS sweep with x as the RHS.
 
   @return returns 0 upon success and non-zero otherwise
 
@@ -47,9 +71,116 @@
 
   @see ComputeSYMGS_ref
 */
-int ComputeSYMGS( const SparseMatrix & A, const Vector & r, Vector & x) {
 
-  // This line and the next two lines should be removed and your version of ComputeSYMGS should be used.
-  return ComputeSYMGS_ref(A, r, x);
+int ComputeSYMGS( const SparseMatrix & A, const Vector & r, Vector & x)
+{
+    sparse_status_t status = SPARSE_STATUS_SUCCESS;
+    struct optData *optData = (struct optData *)A.optimizationData;
+    struct matrix_descr descr;
+    sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+    sparse_matrix_t csrB = (sparse_matrix_t)optData->csrB;
+
+    descr.type = SPARSE_MATRIX_TYPE_TRIANGULAR;
+    descr.mode = SPARSE_FILL_MODE_UPPER;
+    descr.diag = SPARSE_DIAG_NON_UNIT;
+
+    if(A.geom->size > 1)
+    {
+        #ifndef HPCG_NO_MPI
+        ExchangeHalo(A,x);
+        #endif
+
+        status = mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, x.values, 0.0, optData->dtmp4);
+
+        descr.type = SPARSE_MATRIX_TYPE_GENERAL;
+        descr.mode = SPARSE_FILL_MODE_FULL;
+
+        status = mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrB, descr, x.values, 0.0, optData->dtmp2);
+
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+        #endif
+        for ( local_int_t i = 0; i < A.localNumberOfRows; i ++ )
+            optData->dtmp[i] = r.values[i] - optData->dtmp4[i];
+
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+        #endif
+        #pragma ivdep
+        for (local_int_t i=0; i < optData->nrow_b; i++) optData->dtmp[optData->bmap[i]] -= optData->dtmp2[i];
+
+        descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+        descr.mode = SPARSE_FILL_MODE_LOWER;
+
+        mkl_sparse_d_trsv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, optData->dtmp, optData->dtmp3);
+
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+        #endif
+        for ( local_int_t i = 0; i < A.localNumberOfRows; i ++ )
+            optData->dtmp3[i] = optData->dtmp3[i]*optData->diag[i] + optData->dtmp4[i];
+
+        descr.mode = SPARSE_FILL_MODE_UPPER;
+        mkl_sparse_d_trsv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, optData->dtmp3, x.values);
+    } else
+    {
+        descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+        descr.mode = SPARSE_FILL_MODE_FULL;
+        status = mkl_sparse_d_symgs(SPARSE_OPERATION_NON_TRANSPOSE, csrA, descr, 1.0, r.values, x.values);
+    }
+    return 0;
+}
+
+int ComputeSYMGS_MV( const SparseMatrix & A, const Vector & r, Vector & x, Vector & y )
+{
+    sparse_status_t status = SPARSE_STATUS_SUCCESS;
+    struct optData *optData = (struct optData *)A.optimizationData;
+    struct matrix_descr descr;
+    sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+    sparse_matrix_t csrB = (sparse_matrix_t)optData->csrB;
+
+    descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+    descr.mode = SPARSE_FILL_MODE_LOWER;
+    descr.diag = SPARSE_DIAG_NON_UNIT;
+
+    if(A.geom->size > 1)
+    {
+        mkl_sparse_d_trsv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, r.values, optData->dtmp3);
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+        #endif
+        for ( local_int_t i = 0; i < A.localNumberOfRows; i ++ ) optData->dtmp3[i] *= optData->diag[i];
+
+        descr.mode = SPARSE_FILL_MODE_UPPER;
+        mkl_sparse_d_trsv ( SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, optData->dtmp3, x.values);
+
+        descr.type = SPARSE_MATRIX_TYPE_TRIANGULAR;
+        descr.mode = SPARSE_FILL_MODE_LOWER;
+
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+        #endif
+        for ( local_int_t i = 0; i < A.localNumberOfRows; i ++ )
+            y.values[i] = optData->dtmp3[i] - x.values[i]*optData->diag[i];
+
+        status = mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrA, descr, x.values, 1.0, y.values);
+
+        #ifndef HPCG_NO_MPI
+        ExchangeHalo(A,x);
+        #endif
 
+        descr.type = SPARSE_MATRIX_TYPE_GENERAL;
+        descr.mode = SPARSE_FILL_MODE_FULL;
+        status = mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE, 1.0, csrB, descr, x.values, 0.0, optData->dtmp3);
+        #ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+        #endif
+        #pragma ivdep
+        for (local_int_t i=0; i<optData->nrow_b; i++) y.values[optData->bmap[i]] += optData->dtmp3[i];
+    } else
+    {
+        descr.mode = SPARSE_FILL_MODE_FULL;
+        status = mkl_sparse_d_symgs_mv(SPARSE_OPERATION_NON_TRANSPOSE, csrA, descr, 0.0, r.values, x.values, y.values);
+    }
+    return 0;
 }
diff --git a/src/ComputeSYMGS.hpp b/src/ComputeSYMGS.hpp
index 03513b1..329e4b7 100644
--- a/src/ComputeSYMGS.hpp
+++ b/src/ComputeSYMGS.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -17,6 +30,9 @@
 #include "SparseMatrix.hpp"
 #include "Vector.hpp"
 
+
 int ComputeSYMGS( const SparseMatrix  & A, const Vector & r, Vector & x);
+int ComputeSYMGS_MV( const SparseMatrix  & A, const Vector & r, Vector & x, Vector & y);
+int ComputeSPMV_ref( const SparseMatrix & A, Vector  & x, Vector & y);
 
 #endif // COMPUTESYMGS_HPP
diff --git a/src/ComputeSYMGS_ref.cpp b/src/ComputeSYMGS_ref.cpp
index c9b5408..9295792 100644
--- a/src/ComputeSYMGS_ref.cpp
+++ b/src/ComputeSYMGS_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeSYMGS_ref.hpp b/src/ComputeSYMGS_ref.hpp
index 1ab3ab2..fe7f90b 100644
--- a/src/ComputeSYMGS_ref.hpp
+++ b/src/ComputeSYMGS_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeWAXPBY.cpp b/src/ComputeWAXPBY.cpp
index 9effe42..c46e3dd 100644
--- a/src/ComputeWAXPBY.cpp
+++ b/src/ComputeWAXPBY.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeWAXPBY.hpp b/src/ComputeWAXPBY.hpp
index 024ddec..c4e7d08 100644
--- a/src/ComputeWAXPBY.hpp
+++ b/src/ComputeWAXPBY.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ComputeWAXPBY_ref.cpp b/src/ComputeWAXPBY_ref.cpp
index 84ca69f..081a86d 100644
--- a/src/ComputeWAXPBY_ref.cpp
+++ b/src/ComputeWAXPBY_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -42,13 +55,12 @@
 int ComputeWAXPBY_ref(const local_int_t n, const double alpha, const Vector & x,
     const double beta, const Vector & y, Vector & w) {
 
-  assert(x.localLength>=n); // Test vector lengths
-  assert(y.localLength>=n);
-
-  const double * const xv = x.values;
-  const double * const yv = y.values;
-  double * const wv = w.values;
+    assert(x.localLength>=n); // Test vector lengths
+    assert(y.localLength>=n);
 
+    const double * const xv = x.values;
+    const double * const yv = y.values;
+    double * const wv = w.values;
   if (alpha==1.0) {
 #ifndef HPCG_NO_OPENMP
     #pragma omp parallel for
diff --git a/src/ComputeWAXPBY_ref.hpp b/src/ComputeWAXPBY_ref.hpp
index 2f9c39f..6957470 100644
--- a/src/ComputeWAXPBY_ref.hpp
+++ b/src/ComputeWAXPBY_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/ExchangeHalo.cpp b/src/ExchangeHalo.cpp
index 589892b..a1f0450 100644
--- a/src/ExchangeHalo.cpp
+++ b/src/ExchangeHalo.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -34,78 +47,25 @@
 void ExchangeHalo(const SparseMatrix & A, Vector & x) {
 
   // Extract Matrix pieces
+  if ( A.geom->size > 1 )
+  {
+      local_int_t localNumberOfRows = A.localNumberOfRows;
+      double * sendBuffer = A.sendBuffer;
+      local_int_t totalToBeSent = A.totalToBeSent;
+      local_int_t * elementsToSend = A.elementsToSend;
 
-  local_int_t localNumberOfRows = A.localNumberOfRows;
-  int num_neighbors = A.numberOfSendNeighbors;
-  local_int_t * receiveLength = A.receiveLength;
-  local_int_t * sendLength = A.sendLength;
-  int * neighbors = A.neighbors;
-  double * sendBuffer = A.sendBuffer;
-  local_int_t totalToBeSent = A.totalToBeSent;
-  local_int_t * elementsToSend = A.elementsToSend;
+      double * const xv = x.values;
 
-  double * const xv = x.values;
+      double * x_external = (double *) xv + localNumberOfRows;
 
-  int size, rank; // Number of MPI processes, My process ID
-  MPI_Comm_size(MPI_COMM_WORLD, &size);
-  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
-
-  //
-  //  first post receives, these are immediate receives
-  //  Do not wait for result to come, will do that at the
-  //  wait call below.
-  //
-
-  int MPI_MY_TAG = 99;
-
-  MPI_Request * request = new MPI_Request[num_neighbors];
-
-  //
-  // Externals are at end of locals
-  //
-  double * x_external = (double *) xv + localNumberOfRows;
-
-  // Post receives first
-  // TODO: Thread this loop
-  for (int i = 0; i < num_neighbors; i++) {
-    local_int_t n_recv = receiveLength[i];
-    MPI_Irecv(x_external, n_recv, MPI_DOUBLE, neighbors[i], MPI_MY_TAG, MPI_COMM_WORLD, request+i);
-    x_external += n_recv;
-  }
-
-
-  //
-  // Fill up send buffer
-  //
-
-  // TODO: Thread this loop
-  for (local_int_t i=0; i<totalToBeSent; i++) sendBuffer[i] = xv[elementsToSend[i]];
-
-  //
-  // Send to each neighbor
-  //
-
-  // TODO: Thread this loop
-  for (int i = 0; i < num_neighbors; i++) {
-    local_int_t n_send = sendLength[i];
-    MPI_Send(sendBuffer, n_send, MPI_DOUBLE, neighbors[i], MPI_MY_TAG, MPI_COMM_WORLD);
-    sendBuffer += n_send;
-  }
-
-  //
-  // Complete the reads issued above
-  //
+#ifndef HPCG_NO_OPENMP
+      #pragma omp parallel for
+#endif
+      #pragma ivdep
+      for (local_int_t i=0; i<totalToBeSent; i++) sendBuffer[i] = xv[elementsToSend[i]];
 
-  MPI_Status status;
-  // TODO: Thread this loop
-  for (int i = 0; i < num_neighbors; i++) {
-    if ( MPI_Wait(request+i, &status) ) {
-      std::exit(-1); // TODO: have better error exit
-    }
+      MPI_Alltoallv( sendBuffer, A.scounts, A.sdispls, MPI_DOUBLE, x_external, A.rcounts, A.rdispls, MPI_DOUBLE, MPI_COMM_WORLD);
   }
-
-  delete [] request;
-
   return;
 }
 #endif
diff --git a/src/ExchangeHalo.hpp b/src/ExchangeHalo.hpp
index 868aace..70e9323 100644
--- a/src/ExchangeHalo.hpp
+++ b/src/ExchangeHalo.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/GenerateCoarseProblem.cpp b/src/GenerateCoarseProblem.cpp
index b6061f1..9d9d3e6 100644
--- a/src/GenerateCoarseProblem.cpp
+++ b/src/GenerateCoarseProblem.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -69,42 +82,40 @@ void GenerateCoarseProblem(const SparseMatrix & Af) {
   #pragma omp parallel for
 #endif
   for (local_int_t izc=0; izc<nzc; ++izc) {
-    local_int_t izf = 2*izc;
-    for (local_int_t iyc=0; iyc<nyc; ++iyc) {
-      local_int_t iyf = 2*iyc;
-      for (local_int_t ixc=0; ixc<nxc; ++ixc) {
-        local_int_t ixf = 2*ixc;
-        local_int_t currentCoarseRow = izc*nxc*nyc+iyc*nxc+ixc;
-        local_int_t currentFineRow = izf*nxf*nyf+iyf*nxf+ixf;
-        f2cOperator[currentCoarseRow] = currentFineRow;
-      } // end iy loop
-    } // end even iz if statement
+	  local_int_t izf = 2*izc;
+	  for (local_int_t iyc=0; iyc<nyc; ++iyc) {
+		  local_int_t iyf = 2*iyc;
+		  for (local_int_t ixc=0; ixc<nxc; ++ixc) {
+			  local_int_t ixf = 2*ixc;
+			  local_int_t currentCoarseRow = izc*nxc*nyc+iyc*nxc+ixc;
+			  local_int_t currentFineRow = izf*nxf*nyf+iyf*nxf+ixf;
+			  f2cOperator[currentCoarseRow] = currentFineRow;
+		  } // end iy loop
+	  } // end even iz if statement
   } // end iz loop
 
   // Construct the geometry and linear system
   Geometry * geomc = new Geometry;
-  local_int_t zlc = 0; // Coarsen nz for the lower block in the z processor dimension
-  local_int_t zuc = 0; // Coarsen nz for the upper block in the z processor dimension
-  int pz = Af.geom->pz;
-  if (pz>0) {
-    zlc = Af.geom->partz_nz[0]/2; // Coarsen nz for the lower block in the z processor dimension
-    zuc = Af.geom->partz_nz[1]/2; // Coarsen nz for the upper block in the z processor dimension
-  }
-  GenerateGeometry(Af.geom->size, Af.geom->rank, Af.geom->numThreads, Af.geom->pz, zlc, zuc, nxc, nyc, nzc, Af.geom->npx, Af.geom->npy, Af.geom->npz, geomc);
+  GenerateGeometry(Af.geom->size, Af.geom->rank, Af.geom->numThreads, nxc, nyc, nzc, geomc);
 
   SparseMatrix * Ac = new SparseMatrix;
   InitializeSparseMatrix(*Ac, geomc);
+  Ac->nproc = Af.nproc;
   GenerateProblem(*Ac, 0, 0, 0);
   SetupHalo(*Ac);
   Vector *rc = new Vector;
   Vector *xc = new Vector;
   Vector * Axf = new Vector;
   InitializeVector(*rc, Ac->localNumberOfRows);
+  ZeroVector(*rc);
   InitializeVector(*xc, Ac->localNumberOfColumns);
+  ZeroVector(*xc);
   InitializeVector(*Axf, Af.localNumberOfColumns);
+  ZeroVector(*Axf);
   Af.Ac = Ac;
   MGData * mgData = new MGData;
   InitializeMGData(f2cOperator, rc, xc, Axf, *mgData);
+  //printf("%p, %d\n",mgData,localNumberOfRows);fflush(0);
   Af.mgData = mgData;
 
   return;
diff --git a/src/GenerateCoarseProblem.hpp b/src/GenerateCoarseProblem.hpp
index 9595e94..ac115db 100644
--- a/src/GenerateCoarseProblem.hpp
+++ b/src/GenerateCoarseProblem.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/GenerateGeometry.cpp b/src/GenerateGeometry.cpp
index b014554..eeceda3 100644
--- a/src/GenerateGeometry.cpp
+++ b/src/GenerateGeometry.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -20,7 +33,6 @@
 
 #include <cmath>
 #include <cstdlib>
-#include <cassert>
 
 #include "ComputeOptimalShapeXYZ.hpp"
 #include "GenerateGeometry.hpp"
@@ -30,6 +42,7 @@
 #include "hpcg.hpp"
 using std::endl;
 
+#include <cassert>
 #endif
 
 /*!
@@ -42,45 +55,14 @@ using std::endl;
   @param[in]  size total number of MPI processes
   @param[in]  rank this process' rank among other MPI processes
   @param[in]  numThreads number of OpenMP threads in this process
-  @param[in]  pz z-dimension processor ID where second zone of nz values start
   @param[in]  nx, ny, nz number of grid points for each local block in the x, y, and z dimensions, respectively
   @param[out] geom data structure that will store the above parameters and the factoring of total number of processes into three dimensions
 */
-void GenerateGeometry(int size, int rank, int numThreads,
-  int pz, local_int_t zl, local_int_t zu,
-  local_int_t nx, local_int_t ny, local_int_t nz,
-  int npx, int npy, int npz,
-  Geometry * geom)
-{
+void GenerateGeometry(int size, int rank, int numThreads, int nx, int ny, int nz, Geometry * geom) {
 
-  if (npx * npy * npz <= 0 || npx * npy * npz > size)
-    ComputeOptimalShapeXYZ( size, npx, npy, npz );
+  int npx, npy, npz;
 
-  int * partz_ids = 0;
-  local_int_t * partz_nz = 0;
-  int npartz = 0;
-  if (pz==0) { // No variation in nz sizes
-    npartz = 1;
-    partz_ids = new int[1];
-    partz_nz = new local_int_t[1];
-    partz_ids[0] = npz;
-    partz_nz[0] = nz;
-  }
-  else {
-    npartz = 2;
-    partz_ids = new int[2];
-    partz_ids[0] = pz;
-    partz_ids[1] = npz;
-    partz_nz = new local_int_t[2];
-    partz_nz[0] = zl;
-    partz_nz[1] = zu;
-  }
-//  partz_ids[npartz-1] = npz; // The last element of this array is always npz
-  int ipartz_ids = 0;
-  for (int i=0; i< npartz; ++i) {
-    assert(ipartz_ids<partz_ids[i]);  // Make sure that z partitioning is consistent with computed npz value
-    ipartz_ids = partz_ids[i];
-  }
+  ComputeOptimalShapeXYZ( size, npx, npy, npz );
 
   // Now compute this process's indices in the 3D cube
   int ipz = rank/(npx*npy);
@@ -102,7 +84,7 @@ void GenerateGeometry(int size, int rank, int numThreads,
       << "ipy = " << ipy << endl
       << "ipz = " << ipz << endl;
 
-  assert(size>=npx*npy*npz);
+  assert(size==npx*npy*npz);
 #endif
   geom->size = size;
   geom->rank = rank;
@@ -113,57 +95,8 @@ void GenerateGeometry(int size, int rank, int numThreads,
   geom->npx = npx;
   geom->npy = npy;
   geom->npz = npz;
-  geom->pz = pz;
-  geom->npartz = npartz;
-  geom->partz_ids = partz_ids;
-  geom->partz_nz = partz_nz;
   geom->ipx = ipx;
   geom->ipy = ipy;
   geom->ipz = ipz;
-
-// These values should be defined to take into account changes in nx, ny, nz values
-// due to variable local grid sizes
-  global_int_t gnx = npx*nx;
-  global_int_t gny = npy*ny;
-  //global_int_t gnz = npz*nz;
-  // We now permit varying values for nz for any nx-by-ny plane of MPI processes.
-  // npartz is the number of different groups of nx-by-ny groups of processes.
-  // partz_ids is an array of length npartz where each value indicates the z process of the last process in the ith nx-by-ny group.
-  // partz_nz is an array of length npartz containing the value of nz for the ith group.
-
-  //        With no variation, npartz = 1, partz_ids[0] = npz, partz_nz[0] = nz
-
-  global_int_t gnz = 0;
-  ipartz_ids = 0;
-
-  for (int i=0; i< npartz; ++i) {
-    ipartz_ids = partz_ids[i] - ipartz_ids;
-    gnz += partz_nz[i]*ipartz_ids;
-  }
-  //global_int_t giz0 = ipz*nz;
-  global_int_t giz0 = 0;
-  ipartz_ids = 0;
-  for (int i=0; i< npartz; ++i) {
-    int ipart_nz = partz_nz[i];
-    if (ipz < partz_ids[i]) {
-      giz0 += (ipz-ipartz_ids)*ipart_nz;
-      break;
-    } else {
-      ipartz_ids = partz_ids[i];
-      giz0 += ipartz_ids*ipart_nz;
-    }
-
-  }
-  global_int_t gix0 = ipx*nx;
-  global_int_t giy0 = ipy*ny;
-
-// Keep these values for later
-  geom->gnx = gnx;
-  geom->gny = gny;
-  geom->gnz = gnz;
-  geom->gix0 = gix0;
-  geom->giy0 = giy0;
-  geom->giz0 = giz0;
-
   return;
 }
diff --git a/src/GenerateGeometry.hpp b/src/GenerateGeometry.hpp
index d769414..e82ee61 100644
--- a/src/GenerateGeometry.hpp
+++ b/src/GenerateGeometry.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -15,5 +28,5 @@
 #ifndef GENERATEGEOMETRY_HPP
 #define GENERATEGEOMETRY_HPP
 #include "Geometry.hpp"
-void GenerateGeometry(int size, int rank, int numThreads, int pz, local_int_t zl, local_int_t zu, local_int_t nx, local_int_t ny, local_int_t nz, int npx, int npy, int npz, Geometry * geom);
+void GenerateGeometry(int size, int rank, int numThreads, int nx, int ny, int nz, Geometry * geom);
 #endif // GENERATEGEOMETRY_HPP
diff --git a/src/GenerateProblem.cpp b/src/GenerateProblem.cpp
index 8a091e4..9e4cf06 100644
--- a/src/GenerateProblem.cpp
+++ b/src/GenerateProblem.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -25,7 +38,7 @@
 #ifndef HPCG_NO_OPENMP
 #include <omp.h>
 #endif
-
+#include <cassert>
 #include "GenerateProblem.hpp"
 #include "GenerateProblem_ref.hpp"
 
@@ -47,6 +60,319 @@ void GenerateProblem(SparseMatrix & A, Vector * b, Vector * x, Vector * xexact)
   // However, the data structures must remain unchanged such that the CheckProblem function is satisfied.
   // Furthermore, any code must work for general unstructured sparse matrices.  Special knowledge about the
   // specific nature of the sparsity pattern may not be explicitly used.
+  // Make local copies of geometry information.  Use global_int_t since the RHS products in the calculations
+  // below may result in global range values.
+#if 0
+  GenerateProblem_ref(A,b,x,xexact);
+#else
+  // Make local copies of geometry information.  Use global_int_t since the RHS products in the calculations
+  // below may result in global range values.
+//  double t_1 = dsecnd();
+  global_int_t nx = A.geom->nx;
+  global_int_t ny = A.geom->ny;
+  global_int_t nz = A.geom->nz;
+  global_int_t npx = A.geom->npx;
+  global_int_t npy = A.geom->npy;
+  global_int_t npz = A.geom->npz;
+  global_int_t ipx = A.geom->ipx;
+  global_int_t ipy = A.geom->ipy;
+  global_int_t ipz = A.geom->ipz;
+  global_int_t gnx = nx*npx;
+  global_int_t gny = ny*npy;
+  global_int_t gnz = nz*npz;
+  double omp1,omp2;
+
+  local_int_t localNumberOfRows = nx*ny*nz; // This is the size of our subblock
+  // If this assert fails, it most likely means that the local_int_t is set to int and should be set to long long
+  assert(localNumberOfRows>0); // Throw an exception of the number of rows is less than zero (can happen if int overflow)
+  local_int_t numberOfNonzerosPerRow = 27; // We are approximating a 27-point finite element/volume/difference 3D stencil
+
+  global_int_t totalNumberOfRows = ((global_int_t) localNumberOfRows)*((global_int_t) A.geom->size); // Total number of grid points in mesh
+  // If this assert fails, it most likely means that the global_int_t is set to int and should be set to long long
+  assert(totalNumberOfRows>0); // Throw an exception of the number of rows is less than zero (can happen if int overflow)
+//  double t1 = dsecnd();
+  // Allocate arrays that are of length localNumberOfRows
+  char * nonzerosInRow = (char*) MKL_malloc(sizeof(char)*localNumberOfRows, ALIGN);
+  global_int_t ** mtxIndG = (global_int_t**) MKL_malloc(sizeof(global_int_t*)*localNumberOfRows, ALIGN);
+  local_int_t  ** mtxIndL = ( local_int_t**) MKL_malloc(sizeof( local_int_t*)*localNumberOfRows, ALIGN);
+  double ** matrixValues  = (      double**) MKL_malloc(sizeof( double*     )*localNumberOfRows, ALIGN);
+  double ** matrixDiagonal =(      double**) MKL_malloc(sizeof( double*     )*localNumberOfRows, ALIGN);
+  if (b!=0) InitializeVector(*b, localNumberOfRows);
+  if (x!=0) InitializeVector(*x, localNumberOfRows);
+  if (xexact!=0) InitializeVector(*xexact, localNumberOfRows);
+  double * bv = 0;
+  double * xv = 0;
+  double * xexactv = 0;
+  if (b!=0) bv = b->values; // Only compute exact solution if requested
+  if (x!=0) xv = x->values; // Only compute exact solution if requested
+  if (xexact!=0) xexactv = xexact->values; // Only compute exact solution if requested
+  int nproc = A.nproc;
+  A.localToGlobalMap.resize(localNumberOfRows);
+  // Now allocate the arrays pointed to
+  A.mtxL = (local_int_t*) MKL_malloc(sizeof(local_int_t )*numberOfNonzerosPerRow*localNumberOfRows, ALIGN );
+  A.mtxG = (global_int_t*)MKL_malloc(sizeof(global_int_t)*numberOfNonzerosPerRow*localNumberOfRows, ALIGN );
+  A.mtxA = (double*)      MKL_malloc(sizeof(double      )*numberOfNonzerosPerRow*localNumberOfRows, ALIGN );
+
+  A.boundaryRows = (local_int_t*) MKL_malloc( sizeof(local_int_t)*(nx*ny*nz - (nx-2)*(ny-2)*(nz-2)), ALIGN);
+
+  if ( A.mtxL == NULL || A.mtxG == NULL || A.mtxA == NULL || nonzerosInRow == NULL || A.boundaryRows == NULL
+       || mtxIndG == NULL || mtxIndL == NULL || matrixValues == NULL || matrixDiagonal == NULL )
+  {
+      return;
+  }
 
-  return(GenerateProblem_ref(A, b, x, xexact));
+  A.numOfBoundaryRows = 0;
+  local_int_t numOfBoundaryRows = 0;
+#ifndef HPCG_NO_OPENMP
+#pragma omp parallel reduction(+:numOfBoundaryRows) num_threads(nproc)
+#endif
+{
+#ifndef HPCG_NO_OPENMP
+ #pragma omp for nowait
+#endif
+  for (int y = 0; y < ny; y++) {
+    for (int x = 0; x < nx; x++) {
+      A.boundaryRows[y*nx + x] = y*nx + x;
+      numOfBoundaryRows++;
+    }
+  }
+#ifndef HPCG_NO_OPENMP
+  #pragma omp for nowait
+#endif
+  for (int z = 1; z < nz - 1; z++) {
+    for (int x = 0; x < nx; x++) {
+      A.boundaryRows[ny*nx + 2*(z-1)*(nx+ny-2) + x ] = z*ny*nx + x;
+      numOfBoundaryRows++;
+    }
+    for (int y = 1; y < ny - 1; y++) {
+      A.boundaryRows[ny*nx + 2*(z-1)*(nx+ny-2) + nx + 2*(y-1)] = (z*ny + y)*nx;
+      numOfBoundaryRows++;
+      A.boundaryRows[ny*nx + 2*(z-1)*(nx+ny-2) + nx + 2*(y-1)+1] = (z*ny + y)*nx + nx - 1;
+      numOfBoundaryRows++;
+    }
+    for (int x = 0; x < nx; x++) {
+      A.boundaryRows[ny*nx + 2*(z-1)*(nx+ny-2) + nx + 2*(ny-2) + x] = (z*ny + (ny - 1))*nx + x;
+      numOfBoundaryRows++;
+    }
+  }
+#ifndef HPCG_NO_OPENMP
+  #pragma omp for nowait
+#endif
+  for (int y = 0; y < ny; y++) {
+    for (int x = 0; x < nx; x++) {
+      A.boundaryRows[ny*nx + 2*(nz-2)*(nx+ny-2) + y*nx + x] = ((nz - 1)*ny + y)*nx + x;
+      numOfBoundaryRows++;
+    }
+  }
 }
+  A.numOfBoundaryRows = numOfBoundaryRows;
+  local_int_t localNumberOfNonzeros = 0;
+  local_int_t *map_neib_r = (local_int_t*) MKL_malloc( sizeof(local_int_t)*A.geom->size, 512 );
+
+  if ( map_neib_r == NULL ) return;
+
+  for ( local_int_t i = 0; i < A.geom->size; i ++ ) map_neib_r[i] = 0;
+#ifndef HPCG_NO_OPENMP
+#pragma omp parallel reduction(+:localNumberOfNonzeros) num_threads(nproc)
+#endif
+{
+#ifndef HPCG_NO_OPENMP
+    int ithr = omp_get_thread_num();
+    int nthr = omp_get_num_threads();
+#else
+    int ithr = 0;
+    int nthr = 1;
+#endif
+
+    local_int_t works = (nz - 2)*(ny - 2);
+    local_int_t begin = ((ithr  )*works)/nthr;
+    local_int_t end   = ((ithr+1)*works)/nthr;
+    for (local_int_t i = begin; i < end; i++)
+    {
+        local_int_t iz = i/(ny - 2) + 1;
+        local_int_t iy = i%(ny - 2) + 1;
+        
+        for (local_int_t ix=1; ix<nx-1; ix++)
+        {
+            global_int_t giy = ipy*ny+iy;
+            global_int_t giz = ipz*nz+iz;
+            global_int_t gix = ipx*nx+ix;
+            local_int_t currentLocalRow = iz*nx*ny+iy*nx+ix;
+            global_int_t currentGlobalRow = giz*gnx*gny+giy*gnx+gix;
+            A.localToGlobalMap[currentLocalRow ] = currentGlobalRow;
+            mtxIndG[currentLocalRow]      = A.mtxG + currentLocalRow*numberOfNonzerosPerRow;
+            mtxIndL[currentLocalRow]      = A.mtxL + currentLocalRow*numberOfNonzerosPerRow;
+            matrixValues[currentLocalRow] = A.mtxA + currentLocalRow*numberOfNonzerosPerRow;
+            char numberOfNonzerosInRow = 0;
+            double * currentValuePointer = matrixValues[currentLocalRow]; // Pointer to current value in current row
+            global_int_t * currentIndexPointerG = mtxIndG[currentLocalRow]; // Pointer to current index in current row
+            local_int_t  * currentIndexPointerL = mtxIndL[currentLocalRow]; // Pointer to current index in current row
+            for (int sz=-1; sz<=1; sz++) {
+                
+                *(currentValuePointer + 0) = -1.0;
+                *(currentValuePointer + 1) = -1.0;
+                *(currentValuePointer + 2) = -1.0;
+                *(currentValuePointer + 3) = -1.0;
+                *(currentValuePointer + 4) = -1.0;
+                *(currentValuePointer + 5) = -1.0;
+                *(currentValuePointer + 6) = -1.0;
+                *(currentValuePointer + 7) = -1.0;
+                *(currentValuePointer + 8) = -1.0;
+                
+                local_int_t offset = currentLocalRow + sz*ny*nx;
+                *(currentIndexPointerL + 0) = offset - nx - 1;
+                *(currentIndexPointerL + 1) = offset - nx;
+                *(currentIndexPointerL + 2) = offset - nx + 1;
+                *(currentIndexPointerL + 3) = offset - 1;
+                *(currentIndexPointerL + 4) = offset;
+                *(currentIndexPointerL + 5) = offset + 1;
+                *(currentIndexPointerL + 6) = offset + nx - 1;
+                *(currentIndexPointerL + 7) = offset + nx;
+                *(currentIndexPointerL + 8) = offset + nx + 1;
+                currentValuePointer  += 9;
+                currentIndexPointerL += 9;
+            } // end sz loop
+            *(currentValuePointer - 14) = 26.0;
+            matrixDiagonal[currentLocalRow] = currentValuePointer - 14;
+            numberOfNonzerosInRow += 27;
+            nonzerosInRow[currentLocalRow] = numberOfNonzerosInRow;
+            localNumberOfNonzeros += numberOfNonzerosInRow; // Protect this with an atomic
+            if (b!=0)      bv[currentLocalRow] = 26.0 - ((double) (numberOfNonzerosInRow-1));
+            if (x!=0)      xv[currentLocalRow] = 0.0;
+            if (xexact!=0) xexactv[currentLocalRow] = 1.0;
+        } // end ix loop
+    }
+#ifndef HPCG_NO_OPENMP
+#pragma omp for
+#endif
+    for (int i = 0; i < A.numOfBoundaryRows; i++) {
+    local_int_t currentLocalRow = A.boundaryRows[i];
+
+    local_int_t iz = currentLocalRow/(ny*nx);
+    local_int_t iy = currentLocalRow/nx%ny;
+    local_int_t ix = currentLocalRow%nx;
+
+          global_int_t giz = ipz*nz+iz;
+          global_int_t giy = ipy*ny+iy;
+          global_int_t gix = ipx*nx+ix;
+          
+          global_int_t sz_begin = std::max<global_int_t>(-1, -giz);
+          global_int_t sz_end = std::min<global_int_t>(1, gnz - giz - 1);
+          
+          global_int_t sy_begin = std::max<global_int_t>(-1, -giy);
+          global_int_t sy_end = std::min<global_int_t>(1, gny - giy - 1);
+          
+          global_int_t sx_begin = std::max<global_int_t>(-1, -gix);
+          global_int_t sx_end = std::min<global_int_t>(1, gnx - gix - 1);
+
+//          local_int_t currentLocalRow = iz*nx*ny+iy*nx+ix;
+
+          global_int_t currentGlobalRow = giz*gnx*gny+giy*gnx+gix;
+          /*
+          if( A.geom->size > 1 )
+          {
+              #pragma omp critical
+              A.globalToLocalMap[currentGlobalRow] = currentLocalRow;
+          }
+          */
+        mtxIndG[currentLocalRow]      = A.mtxG + currentLocalRow*numberOfNonzerosPerRow;
+        mtxIndL[currentLocalRow]      = A.mtxL + currentLocalRow*numberOfNonzerosPerRow;
+        matrixValues[currentLocalRow] = A.mtxA + currentLocalRow*numberOfNonzerosPerRow;
+        A.localToGlobalMap[currentLocalRow] = currentGlobalRow;
+        char numberOfNonzerosInRow = 0;
+        double * currentValuePointer = matrixValues[currentLocalRow]; // Pointer to current value in current row
+        global_int_t * currentIndexPointerG = mtxIndG[currentLocalRow]; // Pointer to current index in current row
+        local_int_t  * currentIndexPointerL = mtxIndL[currentLocalRow];
+        for (global_int_t sz=sz_begin; sz<=sz_end; sz++) {
+            for (global_int_t sy=sy_begin; sy<=sy_end; sy++) {
+                for (global_int_t sx=sx_begin; sx<=sx_end; sx++) {
+                    global_int_t curcol = currentGlobalRow+sz*gnx*gny+sy*gnx+sx;
+                     local_int_t    col = currentLocalRow +sz*nx*ny+sy*nx+sx;
+                    if (curcol==currentGlobalRow) {
+                      matrixDiagonal[currentLocalRow] = currentValuePointer;
+                      *currentValuePointer++ = 26.0;
+                    } else {
+                      *currentValuePointer++ = -1.0;
+                    }
+                    *currentIndexPointerG++ = curcol;
+                    int rankIdOfColumnEntry = ComputeRankOfMatrixRow(*(A.geom), curcol);
+                    if( A.geom->rank == rankIdOfColumnEntry )
+                    {
+                        *currentIndexPointerL++ = col;
+                    } else {
+                        map_neib_r[rankIdOfColumnEntry] ++;
+                        *currentIndexPointerL++ = -1-rankIdOfColumnEntry;//(- col - 1);
+                    }
+//                      printf("%d %lf %d %d\n",currentLocalRow,currentValuePointer[-1],curcol,numberOfNonzerosInRow);
+                    numberOfNonzerosInRow++;
+                } // end sx loop
+            } // end sy loop
+        } // end sz loop
+        nonzerosInRow[currentLocalRow] = numberOfNonzerosInRow;
+        localNumberOfNonzeros += numberOfNonzerosInRow; // Protect this with an atomic
+        if( b!=0 ) bv[currentLocalRow] = 26.0 - ((double) (numberOfNonzerosInRow-1));
+        if( x!=0 ) xv[currentLocalRow] = 0.0;
+        if( xexact!=0 ) xexactv[currentLocalRow] = 1.0;
+  }
+}
+    for (int i = 0; i < A.numOfBoundaryRows; i++) {
+        local_int_t currentLocalRow = A.boundaryRows[i];
+        
+        local_int_t iz = currentLocalRow/(ny*nx);
+        local_int_t iy = currentLocalRow/nx%ny;
+        local_int_t ix = currentLocalRow%nx;
+        
+        global_int_t giz = ipz*nz+iz;
+        global_int_t giy = ipy*ny+iy;
+        global_int_t gix = ipx*nx+ix;
+        global_int_t currentGlobalRow = giz*gnx*gny+giy*gnx+gix;
+        A.globalToLocalMap[currentGlobalRow] = currentLocalRow;
+    }
+
+  local_int_t number_of_neighbors = 0;
+  if( A.geom->size > 1 ) {
+  for ( local_int_t i = 0; i < A.geom->size; i ++ ) number_of_neighbors += (map_neib_r[i] > 0); }
+  A.work = map_neib_r;
+
+  global_int_t totalNumberOfNonzeros = 0;
+#ifndef HPCG_NO_MPI
+  // Use MPI's reduce function to sum all nonzeros
+#ifdef HPCG_NO_LONG_LONG
+  MPI_Allreduce(&localNumberOfNonzeros, &totalNumberOfNonzeros, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+#else
+  long long lnnz = localNumberOfNonzeros, gnnz = 0; // convert to 64 bit for MPI call
+  MPI_Allreduce(&lnnz, &gnnz, 1, MPI_LONG_LONG_INT, MPI_SUM, MPI_COMM_WORLD);
+  totalNumberOfNonzeros = gnnz; // Copy back
+#endif
+#else
+  totalNumberOfNonzeros = localNumberOfNonzeros;
+#endif
+  // If this assert fails, it most likely means that the global_int_t is set to int and should be set to long long
+  // This assert is usually the first to fail as problem size increases beyond the 32-bit integer range.
+  assert(totalNumberOfNonzeros>0); // Throw an exception of the number of nonzeros is less than zero (can happen if int overflow)
+
+  A.title = 0;
+  A.numberOfSendNeighbors = number_of_neighbors;
+  A.totalNumberOfRows = totalNumberOfRows;
+  A.totalNumberOfNonzeros = totalNumberOfNonzeros;
+  A.localNumberOfRows = localNumberOfRows;
+  A.localNumberOfColumns = localNumberOfRows;
+  A.localNumberOfNonzeros = localNumberOfNonzeros;
+  A.nonzerosInRow = nonzerosInRow;
+  A.mtxIndG = mtxIndG;
+  A.mtxIndL = mtxIndL;
+  A.matrixValues = matrixValues;
+  A.matrixDiagonal = matrixDiagonal;
+//  printf("GenerateProblem: ( %1.4f %1.4f %1.4f %1.4f ) %1.4f %1.4f\n",m1,m2,m3,m5,t4-t2,dsecnd()-t_1);fflush(0);
+//  abort();
+#endif
+  return;
+}
+
+/*
+  char *nonzerosInRow   = (char*)         MKL_malloc( sizeof(char        )*localNumberOfRows, ALIGN );
+  global_int_t *mtxIndG = (global_int_t*) MKL_malloc( sizeof(global_int_t)*localNumberOfRows*numberOfNonzerosPerRow, ALIGN );
+   local_int_t *mtxIndL = (local_int_t* ) MKL_malloc( sizeof( local_int_t)*localNumberOfRows*numberOfNonzerosPerRow, ALIGN );
+  double *matrixValues  = (double*      ) MKL_malloc( sizeof(double      )*localNumberOfRows*numberOfNonzerosPerRow, ALIGN );
+  double *matrixDiagonal= (double*      ) MKL_malloc( sizeof(double      )*localNumberOfRows, ALIGN );
+*/
diff --git a/src/GenerateProblem.hpp b/src/GenerateProblem.hpp
index 85f0ab6..d71bfa0 100644
--- a/src/GenerateProblem.hpp
+++ b/src/GenerateProblem.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -17,5 +30,7 @@
 #include "SparseMatrix.hpp"
 #include "Vector.hpp"
 
+#define ALIGN 512
+
 void GenerateProblem(SparseMatrix & A, Vector * b, Vector * x, Vector * xexact);
 #endif // GENERATEPROBLEM_HPP
diff --git a/src/GenerateProblem_ref.cpp b/src/GenerateProblem_ref.cpp
index 3dd149e..6223ef4 100644
--- a/src/GenerateProblem_ref.cpp
+++ b/src/GenerateProblem_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -54,19 +67,22 @@ void GenerateProblem_ref(SparseMatrix & A, Vector * b, Vector * x, Vector * xexa
   global_int_t nx = A.geom->nx;
   global_int_t ny = A.geom->ny;
   global_int_t nz = A.geom->nz;
-  global_int_t gnx = A.geom->gnx;
-  global_int_t gny = A.geom->gny;
-  global_int_t gnz = A.geom->gnz;
-  global_int_t gix0 = A.geom->gix0;
-  global_int_t giy0 = A.geom->giy0;
-  global_int_t giz0 = A.geom->giz0;
+  global_int_t npx = A.geom->npx;
+  global_int_t npy = A.geom->npy;
+  global_int_t npz = A.geom->npz;
+  global_int_t ipx = A.geom->ipx;
+  global_int_t ipy = A.geom->ipy;
+  global_int_t ipz = A.geom->ipz;
+  global_int_t gnx = nx*npx;
+  global_int_t gny = ny*npy;
+  global_int_t gnz = nz*npz;
 
   local_int_t localNumberOfRows = nx*ny*nz; // This is the size of our subblock
   // If this assert fails, it most likely means that the local_int_t is set to int and should be set to long long
   assert(localNumberOfRows>0); // Throw an exception of the number of rows is less than zero (can happen if int overflow)
   local_int_t numberOfNonzerosPerRow = 27; // We are approximating a 27-point finite element/volume/difference 3D stencil
 
-  global_int_t totalNumberOfRows = gnx*gny*gnz; // Total number of grid points in mesh
+  global_int_t totalNumberOfRows = ((global_int_t) localNumberOfRows)*((global_int_t) A.geom->size); // Total number of grid points in mesh
   // If this assert fails, it most likely means that the global_int_t is set to int and should be set to long long
   assert(totalNumberOfRows>0); // Throw an exception of the number of rows is less than zero (can happen if int overflow)
 
@@ -100,28 +116,14 @@ void GenerateProblem_ref(SparseMatrix & A, Vector * b, Vector * x, Vector * xexa
     mtxIndG[i] = 0;
     mtxIndL[i] = 0;
   }
-
-#ifndef HPCG_CONTIGUOUS_ARRAYS
   // Now allocate the arrays pointed to
-  for (local_int_t i=0; i< localNumberOfRows; ++i)
+  for (local_int_t i=0; i< localNumberOfRows; ++i) {
     mtxIndL[i] = new local_int_t[numberOfNonzerosPerRow];
-  for (local_int_t i=0; i< localNumberOfRows; ++i)
     matrixValues[i] = new double[numberOfNonzerosPerRow];
-  for (local_int_t i=0; i< localNumberOfRows; ++i)
-   mtxIndG[i] = new global_int_t[numberOfNonzerosPerRow];
-
-#else
-  // Now allocate the arrays pointed to
-  mtxIndL[0] = new local_int_t[localNumberOfRows * numberOfNonzerosPerRow];
-  matrixValues[0] = new double[localNumberOfRows * numberOfNonzerosPerRow];
-  mtxIndG[0] = new global_int_t[localNumberOfRows * numberOfNonzerosPerRow];
-
-  for (local_int_t i=1; i< localNumberOfRows; ++i) {
-  mtxIndL[i] = mtxIndL[0] + i * numberOfNonzerosPerRow;
-  matrixValues[i] = matrixValues[0] + i * numberOfNonzerosPerRow;
-  mtxIndG[i] = mtxIndG[0] + i * numberOfNonzerosPerRow;
+    mtxIndG[i] = new global_int_t[numberOfNonzerosPerRow];
   }
-#endif
+
+
 
   local_int_t localNumberOfNonzeros = 0;
   // TODO:  This triply nested loop could be flattened or use nested parallelism
@@ -129,11 +131,11 @@ void GenerateProblem_ref(SparseMatrix & A, Vector * b, Vector * x, Vector * xexa
   #pragma omp parallel for
 #endif
   for (local_int_t iz=0; iz<nz; iz++) {
-    global_int_t giz = giz0+iz;
+    global_int_t giz = ipz*nz+iz;
     for (local_int_t iy=0; iy<ny; iy++) {
-      global_int_t giy = giy0+iy;
+      global_int_t giy = ipy*ny+iy;
       for (local_int_t ix=0; ix<nx; ix++) {
-        global_int_t gix = gix0+ix;
+        global_int_t gix = ipx*nx+ix;
         local_int_t currentLocalRow = iz*nx*ny+iy*nx+ix;
         global_int_t currentGlobalRow = giz*gnx*gny+giy*gnx+gix;
 #ifndef HPCG_NO_OPENMP
diff --git a/src/GenerateProblem_ref.hpp b/src/GenerateProblem_ref.hpp
index f0fd11f..9bf5b69 100644
--- a/src/GenerateProblem_ref.hpp
+++ b/src/GenerateProblem_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/Geometry.hpp b/src/Geometry.hpp
index 98c5465..3522afb 100644
--- a/src/Geometry.hpp
+++ b/src/Geometry.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -48,25 +61,15 @@ struct Geometry_STRUCT {
   int size; //!< Number of MPI processes
   int rank; //!< This process' rank in the range [0 to size - 1]
   int numThreads; //!< This process' number of threads
-  local_int_t nx;   //!< Number of x-direction grid points for each local subdomain
-  local_int_t ny;   //!< Number of y-direction grid points for each local subdomain
-  local_int_t nz;   //!< Number of z-direction grid points for each local subdomain
+  int nx;   //!< Number of x-direction grid points for each local subdomain
+  int ny;   //!< Number of y-direction grid points for each local subdomain
+  int nz;   //!< Number of z-direction grid points for each local subdomain
   int npx;  //!< Number of processors in x-direction
   int npy;  //!< Number of processors in y-direction
   int npz;  //!< Number of processors in z-direction
-  int pz; //!< partition ID of z-dimension process that starts the second region of nz values
-  int npartz; //!< Number of partitions with varying nz values
-  int * partz_ids; //!< Array of partition ids of processor in z-direction where new value of nz starts (valid values are 1 to npz)
-  local_int_t * partz_nz; //!< Array of length npartz containing the nz values for each partition
   int ipx;  //!< Current rank's x location in the npx by npy by npz processor grid
   int ipy;  //!< Current rank's y location in the npx by npy by npz processor grid
   int ipz;  //!< Current rank's z location in the npx by npy by npz processor grid
-  global_int_t gnx;  //!< Global number of x-direction grid points
-  global_int_t gny;  //!< Global number of y-direction grid points
-  global_int_t gnz;  //!< Global number of z-direction grid points
-  global_int_t gix0;  //!< Base global x index for this rank in the npx by npy by npz processor grid
-  global_int_t giy0;  //!< Base global y index for this rank in the npx by npy by npz processor grid
-  global_int_t giz0;  //!< Base global z index for this rank in the npx by npy by npz processor grid
 
 };
 typedef struct Geometry_STRUCT Geometry;
@@ -81,54 +84,18 @@ typedef struct Geometry_STRUCT Geometry;
   @return Returns the MPI rank of the process assigned the row
 */
 inline int ComputeRankOfMatrixRow(const Geometry & geom, global_int_t index) {
-  global_int_t gnx = geom.gnx;
-  global_int_t gny = geom.gny;
+  global_int_t gnx = geom.nx*geom.npx;
+  global_int_t gny = geom.ny*geom.npy;
 
   global_int_t iz = index/(gny*gnx);
   global_int_t iy = (index-iz*gny*gnx)/gnx;
   global_int_t ix = index%gnx;
-  // We now permit varying values for nz for any nx-by-ny plane of MPI processes.
-  // npartz is the number of different groups of nx-by-ny groups of processes.
-  // partz_ids is an array of length npartz where each value indicates the z process of the last process in the ith nx-by-ny group.
-  // partz_nz is an array of length npartz containing the value of nz for the ith group.
-
-  //        With no variation, npartz = 1, partz_ids[0] = npz, partz_nz[0] = nz
-
-  int ipz = 0;
-  int ipartz_ids = 0;
-  for (int i=0; i< geom.npartz; ++i) {
-    int ipart_nz = geom.partz_nz[i];
-    ipartz_ids = geom.partz_ids[i] - ipartz_ids;
-    if (iz<= ipart_nz*ipartz_ids) {
-      ipz += iz/ipart_nz;
-      break;
-    } else {
-      ipz += ipartz_ids;
-      iz -= ipart_nz*ipartz_ids;
-    }
-
-  }
-//  global_int_t ipz = iz/geom.nz;
-  int ipy = iy/geom.ny;
-  int ipx = ix/geom.nx;
+  global_int_t ipz = iz/geom.nz;
+  global_int_t ipy = iy/geom.ny;
+  global_int_t ipx = ix/geom.nx;
   int rank = ipx+ipy*geom.npx+ipz*geom.npy*geom.npx;
   return rank;
 }
 
 
-/*!
- Destructor for geometry data.
-
- @param[inout] data the geometry data structure whose storage is deallocated
- */
-inline void DeleteGeometry(Geometry & geom) {
-
-  delete [] geom.partz_nz;
-  delete [] geom.partz_ids;
-
-  return;
-}
-
-
-
 #endif // GEOMETRY_HPP
diff --git a/src/MGData.hpp b/src/MGData.hpp
index ece8a65..2be4d00 100644
--- a/src/MGData.hpp
+++ b/src/MGData.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/MixedBaseCounter.cpp b/src/MixedBaseCounter.cpp
index 5b57f9b..07f9a6e 100644
--- a/src/MixedBaseCounter.cpp
+++ b/src/MixedBaseCounter.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 #include <map>
 
diff --git a/src/MixedBaseCounter.hpp b/src/MixedBaseCounter.hpp
index 968aba4..eae2339 100644
--- a/src/MixedBaseCounter.hpp
+++ b/src/MixedBaseCounter.hpp
@@ -1,4 +1,16 @@
-
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 class MixedBaseCounter {
   private:
@@ -8,7 +20,7 @@ class MixedBaseCounter {
 
   public:
     MixedBaseCounter(int *counts, int length);
-    MixedBaseCounter(MixedBaseCounter & left, MixedBaseCounter & right);
+    MixedBaseCounter(MixedBaseCounter & left, MixedBaseCounter & right); 
     void next();
     int is_zero();
     int product(int * multipliers);
diff --git a/src/OptimizeProblem.cpp b/src/OptimizeProblem.cpp
index 5247dbe..c574181 100644
--- a/src/OptimizeProblem.cpp
+++ b/src/OptimizeProblem.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -34,68 +47,200 @@
   @see GenerateGeometry
   @see GenerateProblem
 */
-int OptimizeProblem(SparseMatrix & A, CGData & data, Vector & b, Vector & x, Vector & xexact) {
+#include "stdio.h"
+#include "math.h"
 
+#include "mkl.h"
+
+#ifndef HPCG_NO_OPENMP
+#include <omp.h>
+#endif
+
+void OptimizeProblem(SparseMatrix * A, double & t7)
+{
+    double t1 = 0.0;
+    t7 = 0.0;
   // This function can be used to completely transform any part of the data structures.
   // Right now it does nothing, so compiling with a check for unused variables results in complaints
 
-#if defined(HPCG_USE_MULTICOLORING)
-  const local_int_t nrow = A.localNumberOfRows;
-  std::vector<local_int_t> colors(nrow, nrow); // value `nrow' means `uninitialized'; initialized colors go from 0 to nrow-1
-  int totalColors = 1;
-  colors[0] = 0; // first point gets color 0
-
-  // Finds colors in a greedy (a likely non-optimal) fashion.
-
-  for (local_int_t i=1; i < nrow; ++i) {
-    if (colors[i] == nrow) { // if color not assigned
-      std::vector<int> assigned(totalColors, 0);
-      int currentlyAssigned = 0;
-      const local_int_t * const currentColIndices = A.mtxIndL[i];
-      const int currentNumberOfNonzeros = A.nonzerosInRow[i];
-
-      for (int j=0; j< currentNumberOfNonzeros; j++) { // scan neighbors
-        local_int_t curCol = currentColIndices[j];
-        if (curCol < i) { // if this point has an assigned color (points beyond `i' are unassigned)
-          if (assigned[colors[curCol]] == 0)
-            currentlyAssigned += 1;
-          assigned[colors[curCol]] = 1; // this color has been used before by `curCol' point
-        } // else // could take advantage of indices being sorted
-      }
-
-      if (currentlyAssigned < totalColors) { // if there is at least one color left to use
-        for (int j=0; j < totalColors; ++j)  // try all current colors
-          if (assigned[j] == 0) { // if no neighbor with this color
-            colors[i] = j;
-            break;
-          }
-      } else {
-        if (colors[i] == nrow) {
-          colors[i] = totalColors;
-          totalColors += 1;
+//    SparseMatrix *Ac = &A;
+    SparseMatrix *Ac = A;
+    while (Ac != NULL) {
+    local_int_t i, j, k, l, p;
+    struct optData *optData = (struct optData *)mkl_malloc(sizeof(struct optData),128);
+    const local_int_t nrow = Ac->localNumberOfRows;
+    const local_int_t ncol = Ac->localNumberOfColumns;
+    local_int_t nnz = 0, nrow_b = 0, nnz_b = 0;
+    local_int_t nthr = A->nproc;
+    if( Ac->mtxIndG ) { MKL_free(Ac->mtxIndG);       Ac->mtxIndG       = NULL; }
+
+    local_int_t *ia   = (local_int_t*)mkl_malloc(sizeof(local_int_t)*(nrow+1), 512);
+    local_int_t *ia_b = (local_int_t*)mkl_malloc(sizeof(local_int_t)*(nrow+1), 512);
+    local_int_t *bmap = (local_int_t*)mkl_malloc(sizeof(local_int_t)*nrow, 512);
+    double *diag = (double *)mkl_malloc(sizeof(double)*nrow, 512);
+
+    if ( ia == NULL || ia_b == NULL || bmap == NULL || diag == NULL || optData == NULL ) return;
+
+    init_optData(*optData);
+
+    //calculate mkl csr arrays from hpcg matrix representation
+    ia_b[0] = ia[0] = 0;
+#ifndef HPCG_NO_OPENMP    
+    #pragma omp parallel num_threads(nthr) default(shared) private(i,j) reduction(+:nnz)
+#endif    
+    {
+#ifndef HPCG_NO_OPENMP    
+        int ithr = omp_get_thread_num();
+#else
+	int ithr = 0;
+#endif
+
+        for (i = (ithr*nrow)/nthr; i < (ithr+1)*nrow/nthr; i++ )
+        {
+            const double * const cur_vals = Ac->matrixValues[i];
+            const local_int_t *  const cur_inds = Ac->mtxIndL[i];
+            ia_b[i+1] = ia[i+1] = 0;
+            for (j = 0; j < Ac->nonzerosInRow[i]; j++)
+            {
+                if ( cur_inds[j] < nrow ) ia[i+1] ++;
+                else                      ia_b[i+1] ++;
+                if ( cur_inds[j] == i )
+                {
+                    diag[i] = cur_vals[j];
+                }
+            }
+            nnz += ia[i+1];//Ac->nonzerosInRow[i];
         }
-      }
     }
-  }
-
-  std::vector<local_int_t> counters(totalColors);
-  for (local_int_t i=0; i<nrow; ++i)
-    counters[colors[i]]++;
-
-  local_int_t old, old0;
-  for (int i=1; i < totalColors; ++i) {
-    old0 = counters[i];
-    counters[i] = counters[i-1] + old;
-    old = old0;
-  }
-  counters[0] = 0;
-
-  // translate `colors' into a permutation
-  for (local_int_t i=0; i<nrow; ++i) // for each color `c'
-    colors[i] = counters[colors[i]]++;
+
+    for ( i = 0; i < nrow; i ++ ) ia[i+1] += ia[i];
+    nrow_b = 0;
+    for ( i = 0; i < nrow; i ++ )
+    {
+        if( ia_b[i+1] > 0 )
+        {
+            nnz_b += ia_b[i+1];
+            nrow_b ++;
+        }
+    }
+
+    local_int_t *ja = (local_int_t *)mkl_malloc(sizeof(local_int_t)*nnz, 512);
+    double *a = (double *)mkl_malloc(sizeof(double)*nnz, 512);
+
+    if ( ja == NULL || a == NULL ) return;
+#ifndef HPCG_NO_OPENMP
+    #pragma omp parallel num_threads(nthr) default(shared) private(i,j,k,l,p)
+#endif
+    {
+#ifndef HPCG_NO_OPENMP    
+        int ithr = omp_get_thread_num();
+#else
+	int ithr = 0;
 #endif
 
-  return 0;
+        for (i = (ithr*nrow)/nthr; i < (ithr+1)*nrow/nthr; i++ )
+        {
+            const double * const cur_vals = Ac->matrixValues[i];
+            const local_int_t *  const cur_inds = Ac->mtxIndL[i];
+            k = ia[i];
+            for (j = 0; j<Ac->nonzerosInRow[i]; j++)
+            {
+                if ( cur_inds[j] < nrow )
+                {
+                    a [k] = cur_vals[j];
+                    ja[k] = cur_inds[j];
+                    k ++;
+                }
+            }
+        }
+    }
+
+    local_int_t *ja_b = (local_int_t *)mkl_malloc(sizeof(local_int_t)*nnz_b, 512);
+    double *a_b = (double *)mkl_malloc(sizeof(double)*nnz_b, 512);
+
+    if ( (ja_b == NULL || a_b == NULL) && nnz_b > 0 ) return;
+
+    p = k = 0;
+    for (i = 0; i < nrow; i++ )
+    {
+        const double * const cur_vals = Ac->matrixValues[i];
+        const local_int_t *  const cur_inds = Ac->mtxIndL[i];
+
+        if ( ia_b[i+1] > 0 )
+        {
+            for (j = 0; j<Ac->nonzerosInRow[i]; j++)
+            {
+                if ( cur_inds[j] >= nrow )
+                {
+                    a_b [p] = cur_vals[j];
+                    ja_b[p] = cur_inds[j];
+                    p ++;
+                }
+            }
+            bmap[k] = i;
+            ia_b[k+1] = ia_b[i+1];
+            k ++;
+        }
+    }
+    for ( i = 0; i < nrow_b; i ++ ) ia_b[i+1] += ia_b[i];
+
+    if(Ac->mtxL) { MKL_free(Ac->mtxL); Ac->mtxL          = NULL;}
+    if(Ac->mtxA) { MKL_free(Ac->mtxA); Ac->mtxA          = NULL;}
+    if(Ac->nonzerosInRow) { MKL_free(Ac->nonzerosInRow); Ac->nonzerosInRow = NULL; }
+    if(Ac->matrixValues) { MKL_free(Ac->matrixValues);  Ac->matrixValues  = NULL; }
+    if(Ac->mtxIndL) { MKL_free(Ac->mtxIndL);       Ac->mtxIndL       = NULL; }
+
+    t1 = mytimer();
+
+    sparse_status_t status = SPARSE_STATUS_SUCCESS;
+    struct matrix_descr descr;
+    sparse_matrix_t csrA = NULL, csrB = NULL;
+    descr.type = SPARSE_MATRIX_TYPE_SYMMETRIC;
+    descr.mode = SPARSE_FILL_MODE_FULL;
+    descr.diag = SPARSE_DIAG_NON_UNIT;
+
+    status = mkl_sparse_d_create_csr ( &csrA, SPARSE_INDEX_BASE_ZERO, nrow, nrow, ia, ia+1, ja, a );
+
+    status = mkl_sparse_d_create_csr ( &csrB, SPARSE_INDEX_BASE_ZERO, nrow_b, ncol, ia_b, ia_b+1, ja_b, a_b );
+
+    status = mkl_sparse_set_symgs_hint ( csrA, SPARSE_OPERATION_NON_TRANSPOSE, descr, 20);
+    status = mkl_sparse_set_memory_hint( csrA, SPARSE_MEMORY_NONE);
+
+
+    descr.type = SPARSE_MATRIX_TYPE_GENERAL;
+    descr.mode = SPARSE_FILL_MODE_FULL;
+    descr.diag = SPARSE_DIAG_NON_UNIT;
+    status = mkl_sparse_set_mv_hint ( csrB, SPARSE_OPERATION_NON_TRANSPOSE, descr, 199);
+
+    status = mkl_sparse_optimize( csrA );
+
+    mkl_free(ia); mkl_free(ja); mkl_free(a);
+
+    status = mkl_sparse_optimize(csrB);
+
+    t7 += (mytimer() - t1);
+
+    mkl_free(ia_b); mkl_free(ja_b); mkl_free(a_b);
+
+    double *dtmp = (double *)mkl_malloc(sizeof(double)*4*nrow, 512);
+
+    if ( dtmp == NULL ) return;
+
+    optData->csrA  = csrA;
+    optData->csrB  = csrB;
+    optData->diag  = diag;
+    optData->dtmp  = dtmp;
+    optData->dtmp2 = dtmp + nrow;
+    optData->dtmp3 = dtmp + 2*nrow;
+    optData->dtmp4 = dtmp + 3*nrow;
+    optData->bmap  = bmap;
+    optData->nrow_b = nrow_b;
+
+
+
+    Ac->optimizationData = optData;
+    Ac = Ac->Ac;
+    }//while Ac!=NULL
 }
 
 // Helper function (see OptimizeProblem.hpp for details)
diff --git a/src/OptimizeProblem.hpp b/src/OptimizeProblem.hpp
index 5f1b50d..fd389a8 100644
--- a/src/OptimizeProblem.hpp
+++ b/src/OptimizeProblem.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -18,8 +31,12 @@
 #include "SparseMatrix.hpp"
 #include "Vector.hpp"
 #include "CGData.hpp"
+#include "mytimer.hpp"
 
-int OptimizeProblem(SparseMatrix & A, CGData & data,  Vector & b, Vector & x, Vector & xexact);
+#include "mkl_spblas.h"
+#include "mkl_service.h"
+//int OptimizeProblem(SparseMatrix & A, CGData & data,  Vector & b, Vector & x, Vector & xexact);
+void OptimizeProblem(SparseMatrix * A, double & t7);
 
 // This helper function should be implemented in a non-trivial way if OptimizeProblem is non-trivial
 // It should return as type double, the total number of bytes allocated and retained after calling OptimizeProblem.
diff --git a/src/OutputFile.cpp b/src/OutputFile.cpp
deleted file mode 100644
index cd5f29f..0000000
--- a/src/OutputFile.cpp
+++ /dev/null
@@ -1,135 +0,0 @@
-
-//@HEADER
-// ***************************************************
-//
-// HPCG: High Performance Conjugate Gradient Benchmark
-//
-// Contact:
-// Michael A. Heroux ( maherou@sandia.gov)
-// Jack Dongarra     (dongarra@eecs.utk.edu)
-// Piotr Luszczek    (luszczek@eecs.utk.edu)
-//
-// ***************************************************
-//@HEADER
-
-
-#include <fstream>
-#include <list>
-#include <sstream>
-#include <string>
-
-#include "OutputFile.hpp"
-
-using std::string;
-using std::stringstream;
-using std::list;
-using std::ofstream;
-
-OutputFile::OutputFile(const string & name_arg, const string & version_arg)
-  : name(name_arg), version(version_arg), eol("\n"), keySeparator("::") {}
-
-OutputFile::OutputFile(void) : eol("\n"), keySeparator("::") {}
-
-OutputFile::~OutputFile() {
-  for (list<OutputFile*>::iterator it = descendants.begin(); it != descendants.end(); ++it) {
-    delete *it;
-  }
-}
-
-void
-OutputFile::add(const string & key_arg, const string & value_arg) {
-  descendants.push_back(allocKeyVal(key_arg, value_arg));
-}
-
-void
-OutputFile::add(const string & key_arg, double value_arg) {
-  stringstream ss;
-  ss << value_arg;
-  descendants.push_back(allocKeyVal(key_arg, ss.str()));
-}
-
-void
-OutputFile::add(const string & key_arg, int value_arg) {
-  stringstream ss;
-  ss << value_arg;
-  descendants.push_back(allocKeyVal(key_arg, ss.str()));
-}
-
-#ifndef HPCG_NO_LONG_LONG
-
-void
-OutputFile::add(const string & key_arg, long long value_arg) {
-  stringstream ss;
-  ss << value_arg;
-  descendants.push_back(allocKeyVal(key_arg, ss.str()));
-}
-
-#endif
-
-void
-OutputFile::add(const string & key_arg, size_t value_arg) {
-  stringstream ss;
-  ss << value_arg;
-  descendants.push_back(allocKeyVal(key_arg, ss.str()));
-}
-
-void
-OutputFile::setKeyValue(const string & key_arg, const string & value_arg) {
-  key = key_arg;
-  value = value_arg;
-}
-
-OutputFile *
-OutputFile::get(const string & key_arg) {
-  for (list<OutputFile*>::iterator it = descendants.begin(); it != descendants.end(); ++it) {
-    if ((*it)->key == key_arg)
-      return *it;
-  }
-
-  return 0;
-}
-
-string
-OutputFile::generateRecursive(string prefix) {
-  string result = "";
-
-  result += prefix + key + "=" + value + eol;
-
-  for (list<OutputFile*>::iterator it = descendants.begin(); it != descendants.end(); ++it) {
-    result += (*it)->generateRecursive(prefix + key + keySeparator);
-  }
-
-  return result;
-}
-
-string
-OutputFile::generate(void) {
-  string result = name + "\nversion=" + version + eol;
-
-  for (list<OutputFile*>::iterator it = descendants.begin(); it != descendants.end(); ++it) {
-    result += (*it)->generateRecursive("");
-  }
-
-  time_t rawtime;
-  time(&rawtime);
-  tm * ptm = localtime(&rawtime);
-  char sdate[25];
-  //use tm_mon+1 because tm_mon is 0 .. 11 instead of 1 .. 12
-  sprintf (sdate,"%04d-%02d-%02d_%02d-%02d-%02d",ptm->tm_year + 1900, ptm->tm_mon+1,
-        ptm->tm_mday, ptm->tm_hour, ptm->tm_min,ptm->tm_sec);
-
-  string filename = name + "_" + version + "_";
-  filename += string(sdate) + ".txt";
-
-  ofstream myfile(filename.c_str());
-  myfile << result;
-  myfile.close();
-
-  return result;
-}
-
-OutputFile * OutputFile::allocKeyVal(const std::string & key_arg, const std::string & value_arg) {
-  OutputFile * of = new OutputFile();
-  of->setKeyValue(key_arg, value_arg);
-  return of;
-}
diff --git a/src/OutputFile.hpp b/src/OutputFile.hpp
deleted file mode 100644
index 3b13d92..0000000
--- a/src/OutputFile.hpp
+++ /dev/null
@@ -1,160 +0,0 @@
-
-//@HEADER
-// ***************************************************
-//
-// HPCG: High Performance Conjugate Gradient Benchmark
-//
-// Contact:
-// Michael A. Heroux ( maherou@sandia.gov)
-// Jack Dongarra     (dongarra@eecs.utk.edu)
-// Piotr Luszczek    (luszczek@eecs.utk.edu)
-//
-// ***************************************************
-//@HEADER
-
-/*!
- @file Output_File.hpp
-
- HPCG output file classes
- */
-
-#ifndef OUTPUTFILE_HPP
-#define OUTPUTFILE_HPP
-
-#include <list>
-#include <string>
-
-//! The OutputFile class for the uniform collecting and reporting of performance data for HPCG
-
-/*!
-
-  The OutputFile class facilitates easy collecting and reporting of
-  key-value-formatted data that can be then registered with the HPCG results
-  collection website. The keys may have hierarchy key1::key2::key3=val with
-  double colon :: as a separator. A sample output may look like this (note how
-  "major" and "micro" keys repeat with different ancestor keys):
-
-\code
-
-version=3.2.1alpha
-version::major=3
-version::minor=2
-version::micro=1
-version::release=alpha
-axis=xyz
-axis::major=x
-axis::minor=y
-
-\endcode
-
-*/
-class OutputFile {
-protected:
-  std::list<OutputFile *> descendants; //!< descendant elements
-  std::string name; //!< name of the benchmark
-  std::string version; //!< version of the benchmark
-  std::string key; //!< the key under which the element is stored
-  std::string value; //!< the value of the stored element
-  std::string eol; //!< end-of-line character sequence in the output file
-  std::string keySeparator; //!< character sequence to separate keys in the output file
-
-  //! Recursively generate output string from descendant list, and their descendants and so on
-  std::string generateRecursive(std::string prefix);
-
-public:
-  static OutputFile * allocKeyVal(const std::string & key, const std::string & value);
-
-  //! Constructor: accepts name and version as strings that are used to create a file name for printing results.
-  /*!
-    This constructor accepts and name and version number for the benchmark that
-    are used to form a file name information for results that are generated by
-    the generate() method.
-    \param name (in) string containing name of the benchmark
-    \param version (in) string containing the version of the benchmark
-  */
-  OutputFile(const std::string & name, const std::string & version);
-
-  //! Default constructor: no-arguments accepted, should be used for descendant nodes
-  /*!
-    This no-argument constructor can be used for descendant nodes to provide
-    key1::key2::key3=val output. Unlike the root node, descendant nodes do not
-    have name and version but only store key-value pairs.
-  */
-  OutputFile(void);
-
-  ~OutputFile();
-
-  //! Create and add a descendant element with value of type "string"
-  /*!
-  Create and add a descendant element identified by "key" and associated with
-  "value".  The element is added at the end of a list of previously added
-  elements.
-
-  @param[in] key   The key that identifies the added element and under which the element is stored
-  @param[in] value The value stored by the element
-  */
-  void add(const std::string & key, const std::string & value);
-
-  //! Create and add a descendant element with value of type "double"
-  /*!
-  Create and add a descendant element identified by "key" and associated with
-  "value".  The element is added at the end of a list of previously added
-  elements.
-
-  @param[in] key   The key that identifies the added element and under which the element is stored
-  @param[in] value The value stored by the element
-  */
-   void add(const std::string & key, double value);
-
-  //! Create and add a descendant element with value of type "int"
-  /*!
-  Create and add a descendant element identified by "key" and associated with
-  "value".  The element is added at the end of a list of previously added
-  elements.
-
-  @param[in] key   The key that identifies the added element and under which the element is stored
-  @param[in] value The value stored by the element
-  */
-   void add(const std::string & key, int value);
-
-#ifndef HPCG_NO_LONG_LONG
-  //! Create and add a descendant element with value of type "long long"
-  /*!
-  Create and add a descendant element identified by "key" and associated with
-  "value".  The element is added at the end of a list of previously added
-  elements.
-
-  @param[in] key   The key that identifies the added element and under which the element is stored
-  @param[in] value The value stored by the element
-  */
-   void add(const std::string & key, long long value);
-#endif
-
-  //! Create and add a descendant element with value of type "size_t"
-  /*!
-  Create and add a descendant element identified by "key" and associated with
-  "value".  The element is added at the end of a list of previously added
-  elements.
-
-  @param[in] key   The key that identifies the added element and under which the element is stored
-  @param[in] value The value stored by the element
-  */
-   void add(const std::string & key, size_t value);
-
-  //! Key-Value setter method
-  /*!
-  Set the key and the value of this element.
-
-  @param[in] key   The key that identifies this element and under which the element is stored
-  @param[in] value The value stored by the element
-  */
-  void setKeyValue(const std::string & key, const std::string & value);
-
-  //! Get the element in the list with the given key or return NULL if not found
-  OutputFile * get(const std::string & key);
-
-  //! Generate output string with results based on the stored key-value hierarchy
-  std::string generate(void);
-};
-
-#endif // OUTPUTFILE_HPP
diff --git a/src/ReadHpcgDat.cpp b/src/ReadHpcgDat.cpp
index 746afec..3af0ceb 100644
--- a/src/ReadHpcgDat.cpp
+++ b/src/ReadHpcgDat.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -39,7 +52,7 @@ SkipUntilEol(FILE *stream) {
 }
 
 int
-ReadHpcgDat(int *localDimensions, int *secondsPerRun, int *localProcDimensions) {
+ReadHpcgDat(int *localDimensions, int *secondsPerRun) {
   FILE * hpcgStream = fopen("hpcg.dat", "r");
 
   if (! hpcgStream)
@@ -56,17 +69,10 @@ ReadHpcgDat(int *localDimensions, int *secondsPerRun, int *localProcDimensions)
   SkipUntilEol( hpcgStream ); // skip the rest of the second line
 
   if (secondsPerRun!=0) { // Only read number of seconds if the pointer is non-zero
-    if (fscanf(hpcgStream, "%d", secondsPerRun) != 1 || secondsPerRun[0] < 0)
-      secondsPerRun[0] = 30 * 60; // 30 minutes
+	  if (fscanf(hpcgStream, "%d", secondsPerRun) != 1 || secondsPerRun[0] < 0)
+		  secondsPerRun[0] = 30 * 60; // 30 minutes
   }
 
-  SkipUntilEol( hpcgStream ); // skip the rest of the third line
-
-  for (int i = 0; i < 3; ++i)
-    // the user didn't specify (or values are invalid) process dimensions
-    if (fscanf(hpcgStream, "%d", localProcDimensions+i) != 1 || localProcDimensions[i] < 1)
-      localProcDimensions[i] = 0; // value 0 means: "not specified" and it will be fixed later
-
   fclose(hpcgStream);
 
   return 0;
diff --git a/src/ReadHpcgDat.hpp b/src/ReadHpcgDat.hpp
index d549d17..e6aaa40 100644
--- a/src/ReadHpcgDat.hpp
+++ b/src/ReadHpcgDat.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -15,6 +28,6 @@
 #ifndef READHPCGDAT_HPP
 #define READHPCGDAT_HPP
 
-int ReadHpcgDat(int *localDimensions, int *secondsPerRun, int *localProcDimensions);
+int ReadHpcgDat(int *localDimensions, int *secondsPerRun);
 
 #endif // READHPCGDAT_HPP
diff --git a/src/ReportResults.cpp b/src/ReportResults.cpp
index c775dd5..352dd85 100644
--- a/src/ReportResults.cpp
+++ b/src/ReportResults.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -24,7 +37,8 @@
 
 #include <vector>
 #include "ReportResults.hpp"
-#include "OutputFile.hpp"
+#include "YAML_Element.hpp"
+#include "YAML_Doc.hpp"
 #include "OptimizeProblem.hpp"
 
 #ifdef HPCG_DEBUG
@@ -34,6 +48,7 @@ using std::endl;
 #include "hpcg.hpp"
 #endif
 
+
 /*!
  Creates a YAML file and writes the information about the HPCG run, its results, and validity.
 
@@ -46,14 +61,15 @@ using std::endl;
   @param[in] testcg_data    the data structure with the results of the CG-correctness test including pass/fail information
   @param[in] testsymmetry_data the data structure with the results of the CG symmetry test including pass/fail information
   @param[in] testnorms_data the data structure with the results of the CG norm test including pass/fail information
-  @param[in] global_failure indicates whether a failure occurred during the correctness tests of CG
+  @param[in] global_failure indicates whether a failure occured during the correctness tests of CG
 
   @see YAML_Doc
 */
 void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgSets, int refMaxIters,int optMaxIters, double times[],
-    const TestCGData & testcg_data, const TestSymmetryData & testsymmetry_data, const TestNormsData & testnorms_data, int global_failure, bool quickPath) {
+		   const TestCGData & testcg_data, const TestSymmetryData & testsymmetry_data, const TestNormsData & testnorms_data, int global_failure, bool quickPath,
+		   const HPCG_Params& params) {
 
-  double minOfficialTime = 1800; // Any official benchmark result must run at least this many seconds
+  double minOfficialTime = 1800; // Any official benchmark result much run at least this many seconds
 
 #ifndef HPCG_NO_MPI
   double t4 = times[4];
@@ -66,13 +82,15 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
   t4avg = t4avg/((double) A.geom->size);
 #endif
 
+  // initialize YAML doc
+
   if (A.geom->rank==0) { // Only PE 0 needs to compute and report timing results
 
-    // TODO: Put the FLOP count, Memory BW and Memory Usage models into separate functions
+// TODO: Put the FLOP count, Memory BW and Memory Usage models into separate functions
 
-    // ======================== FLOP count model =======================================
+	  // ======================== FLOP count model =======================================
 
-    double fNumberOfCgSets = numberOfCgSets;
+	double fNumberOfCgSets = numberOfCgSets;
     double fniters = fNumberOfCgSets * (double) optMaxIters;
     double fnrow = A.totalNumberOfRows;
     double fnnz = A.totalNumberOfNonzeros;
@@ -85,13 +103,13 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     double fnops_precond = 0.0;
     const SparseMatrix * Af = &A;
     for (int i=1; i<numberOfMgLevels; ++i) {
-      double fnnz_Af = Af->totalNumberOfNonzeros;
-      double fnumberOfPresmootherSteps = Af->mgData->numberOfPresmootherSteps;
-      double fnumberOfPostsmootherSteps = Af->mgData->numberOfPostsmootherSteps;
-      fnops_precond += fnumberOfPresmootherSteps*fniters*4.0*fnnz_Af; // number of presmoother flops
-      fnops_precond += fniters*2.0*fnnz_Af; // cost of fine grid residual calculation
-      fnops_precond += fnumberOfPostsmootherSteps*fniters*4.0*fnnz_Af;  // number of postsmoother flops
-      Af = Af->Ac; // Go to next coarse level
+        double fnnz_Af = Af->totalNumberOfNonzeros;
+        double fnumberOfPresmootherSteps = Af->mgData->numberOfPresmootherSteps;
+        double fnumberOfPostsmootherSteps = Af->mgData->numberOfPostsmootherSteps;
+        fnops_precond += fnumberOfPresmootherSteps*fniters*4.0*fnnz_Af; // number of presmoother flops
+        fnops_precond += fniters*2.0*fnnz_Af; // cost of fine grid residual calculation
+        fnops_precond += fnumberOfPostsmootherSteps*fniters*4.0*fnnz_Af;  // number of postsmoother flops
+    	Af = Af->Ac; // Go to next coarse level
     }
 
     fnops_precond += fniters*4.0*((double) Af->totalNumberOfNonzeros); // One symmetric GS sweep at the coarsest level
@@ -106,24 +124,24 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     double fnreads_waxpby = (3.0*fniters+fNumberOfCgSets)*2.0*fnrow*sizeof(double); // 3 WAXPBYs with nrow adds and nrow mults
     double fnwrites_waxpby = (3.0*fniters+fNumberOfCgSets)*fnrow*sizeof(double); // 3 WAXPBYs with nrow adds and nrow mults
     double fnreads_sparsemv = (fniters+fNumberOfCgSets)*(fnnz*(sizeof(double)+sizeof(local_int_t)) + fnrow*sizeof(double));// 1 SpMV with nnz reads of values, nnz reads indices,
-    // plus nrow reads of x
+                                                                                                                           // plus nrow reads of x
     double fnwrites_sparsemv = (fniters+fNumberOfCgSets)*fnrow*sizeof(double); // 1 SpMV nrow writes
     // Op counts from the multigrid preconditioners
     double fnreads_precond = 0.0;
     double fnwrites_precond = 0.0;
     Af = &A;
     for (int i=1; i<numberOfMgLevels; ++i) {
-      double fnnz_Af = Af->totalNumberOfNonzeros;
-      double fnrow_Af = Af->totalNumberOfRows;
-      double fnumberOfPresmootherSteps = Af->mgData->numberOfPresmootherSteps;
-      double fnumberOfPostsmootherSteps = Af->mgData->numberOfPostsmootherSteps;
-      fnreads_precond += fnumberOfPresmootherSteps*fniters*(2.0*fnnz_Af*(sizeof(double)+sizeof(local_int_t)) + fnrow_Af*sizeof(double)); // number of presmoother reads
-      fnwrites_precond += fnumberOfPresmootherSteps*fniters*fnrow_Af*sizeof(double); // number of presmoother writes
-      fnreads_precond += fniters*(fnnz_Af*(sizeof(double)+sizeof(local_int_t)) + fnrow_Af*sizeof(double)); // Number of reads for fine grid residual calculation
-      fnwrites_precond += fniters*fnnz_Af*sizeof(double); // Number of writes for fine grid residual calculation
-      fnreads_precond += fnumberOfPostsmootherSteps*fniters*(2.0*fnnz_Af*(sizeof(double)+sizeof(local_int_t)) + fnrow_Af*sizeof(double));  // number of postsmoother reads
-      fnwrites_precond += fnumberOfPostsmootherSteps*fniters*fnnz_Af*sizeof(double);  // number of postsmoother writes
-      Af = Af->Ac; // Go to next coarse level
+        double fnnz_Af = Af->totalNumberOfNonzeros;
+        double fnrow_Af = Af->totalNumberOfRows;
+        double fnumberOfPresmootherSteps = Af->mgData->numberOfPresmootherSteps;
+        double fnumberOfPostsmootherSteps = Af->mgData->numberOfPostsmootherSteps;
+        fnreads_precond += fnumberOfPresmootherSteps*fniters*(2.0*fnnz_Af*(sizeof(double)+sizeof(local_int_t)) + fnrow_Af*sizeof(double)); // number of presmoother reads
+        fnwrites_precond += fnumberOfPresmootherSteps*fniters*fnrow_Af*sizeof(double); // number of presmoother writes
+        fnreads_precond += fniters*(fnnz_Af*(sizeof(double)+sizeof(local_int_t)) + fnrow_Af*sizeof(double)); // Number of reads for fine grid residual calculation
+        fnwrites_precond += fniters*fnnz_Af*sizeof(double); // Number of writes for fine grid residual calculation
+        fnreads_precond += fnumberOfPostsmootherSteps*fniters*(2.0*fnnz_Af*(sizeof(double)+sizeof(local_int_t)) + fnrow_Af*sizeof(double));  // number of postsmoother reads
+        fnwrites_precond += fnumberOfPostsmootherSteps*fniters*fnnz_Af*sizeof(double);  // number of postsmoother writes
+    	Af = Af->Ac; // Go to next coarse level
     }
 
     double fnnz_Af = Af->totalNumberOfNonzeros;
@@ -171,35 +189,35 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
 
     Af = A.Ac;
     for (int i=1; i<numberOfMgLevels; ++i) {
-      double fnrow_Af = Af->totalNumberOfRows;
-      double fncol_Af = ((global_int_t) Af->localNumberOfColumns) * size; // Estimate of the global number of columns using the value from rank 0
-      double fnbytes_Af = 0.0;
-      // Model for GenerateCoarseProblem.cpp
-      fnbytes_Af += fnrow_Af*((double) sizeof(local_int_t)); // f2cOperator
-      fnbytes_Af += fnrow_Af*((double) sizeof(double)); // rc
-      fnbytes_Af += 2.0*fncol_Af*((double) sizeof(double)); // xc, Axf are estimated based on the size of these arrays on rank 0
-      fnbytes_Af += ((double) (sizeof(Geometry)+sizeof(SparseMatrix)+3*sizeof(Vector)+sizeof(MGData))); // Account for structs geomc, Ac, rc, xc, Axf - (minor)
-
-      // Model for GenerateProblem.cpp (called within GenerateCoarseProblem.cpp)
-      fnbytes_Af += fnrow_Af*sizeof(char);      // array nonzerosInRow
-      fnbytes_Af += fnrow_Af*((double) sizeof(global_int_t*)); // mtxIndG
-      fnbytes_Af += fnrow_Af*((double) sizeof(local_int_t*));  // mtxIndL
-      fnbytes_Af += fnrow_Af*((double) sizeof(double*));      // matrixValues
-      fnbytes_Af += fnrow_Af*((double) sizeof(double*));      // matrixDiagonal
-      fnbytes_Af += fnrow_Af*numberOfNonzerosPerRow*((double) sizeof(local_int_t));  // mtxIndL[1..nrows]
-      fnbytes_Af += fnrow_Af*numberOfNonzerosPerRow*((double) sizeof(double));       // matrixValues[1..nrows]
-      fnbytes_Af += fnrow_Af*numberOfNonzerosPerRow*((double) sizeof(global_int_t)); // mtxIndG[1..nrows]
-
-      // Model for SetupHalo_ref.cpp
+        double fnrow_Af = Af->totalNumberOfRows;
+        double fncol_Af = ((global_int_t) Af->localNumberOfColumns) * size; // Estimate of the global number of columns using the value from rank 0
+        double fnbytes_Af = 0.0;
+        // Model for GenerateCoarseProblem.cpp
+        fnbytes_Af += fnrow_Af*((double) sizeof(local_int_t)); // f2cOperator
+        fnbytes_Af += fnrow_Af*((double) sizeof(double)); // rc
+        fnbytes_Af += 2.0*fncol_Af*((double) sizeof(double)); // xc, Axf are estimated based on the size of these arrays on rank 0
+        fnbytes_Af += ((double) (sizeof(Geometry)+sizeof(SparseMatrix)+3*sizeof(Vector)+sizeof(MGData))); // Account for structs geomc, Ac, rc, xc, Axf - (minor)
+
+        // Model for GenerateProblem.cpp (called within GenerateCoarseProblem.cpp)
+        fnbytes_Af += fnrow_Af*sizeof(char);      // array nonzerosInRow
+        fnbytes_Af += fnrow_Af*((double) sizeof(global_int_t*)); // mtxIndG
+        fnbytes_Af += fnrow_Af*((double) sizeof(local_int_t*));  // mtxIndL
+        fnbytes_Af += fnrow_Af*((double) sizeof(double*));      // matrixValues
+        fnbytes_Af += fnrow_Af*((double) sizeof(double*));      // matrixDiagonal
+        fnbytes_Af += fnrow_Af*numberOfNonzerosPerRow*((double) sizeof(local_int_t));  // mtxIndL[1..nrows]
+        fnbytes_Af += fnrow_Af*numberOfNonzerosPerRow*((double) sizeof(double));       // matrixValues[1..nrows]
+        fnbytes_Af += fnrow_Af*numberOfNonzerosPerRow*((double) sizeof(global_int_t)); // mtxIndG[1..nrows]
+
+        // Model for SetupHalo_ref.cpp
 #ifndef HPCG_NO_MPI
-      fnbytes_Af += ((double) sizeof(double)*Af->totalToBeSent); //sendBuffer
-      fnbytes_Af += ((double) sizeof(local_int_t)*Af->totalToBeSent); // elementsToSend
-      fnbytes_Af += ((double) sizeof(int)*Af->numberOfSendNeighbors); // neighbors
-      fnbytes_Af += ((double) sizeof(local_int_t)*Af->numberOfSendNeighbors); // receiveLength, sendLength
+        fnbytes_Af += ((double) sizeof(double)*Af->totalToBeSent); //sendBuffer
+        fnbytes_Af += ((double) sizeof(local_int_t)*Af->totalToBeSent); // elementsToSend
+        fnbytes_Af += ((double) sizeof(int)*Af->numberOfSendNeighbors); // neighbors
+        fnbytes_Af += ((double) sizeof(local_int_t)*Af->numberOfSendNeighbors); // receiveLength, sendLength
 #endif
-      fnbytesPerLevel[i] = fnbytes_Af;
-      fnbytes += fnbytes_Af; // Running sum
-      Af = Af->Ac; // Go to next coarse level
+        fnbytesPerLevel[i] = fnbytes_Af;
+        fnbytes += fnbytes_Af; // Running sum
+    	Af = Af->Ac; // Go to next coarse level
     }
 
     assert(Af==0); // Make sure we got to the lowest grid level
@@ -207,8 +225,12 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     // Count number of bytes used per equation
     double fnbytesPerEquation = fnbytes/fnrow;
 
+    char buf[1024];
+    sprintf(buf, "n%d-%dp-%dt", A.geom->nx, A.geom->size, A.geom->numThreads);
+    std::string fileName(buf);
     // Instantiate YAML document
-    OutputFile doc("HPCG-Benchmark", "3.0");
+    YAML_Doc doc(fileName, "V3.0", "", params.yamlFileName);
+//    YAML_Doc doc("HPCG-Benchmark", "3.0");
     doc.add("Release date", "November 11, 2015");
 
     doc.add("Machine Summary","");
@@ -216,9 +238,9 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     doc.get("Machine Summary")->add("Threads per processes",A.geom->numThreads);
 
     doc.add("Global Problem Dimensions","");
-    doc.get("Global Problem Dimensions")->add("Global nx",A.geom->gnx);
-    doc.get("Global Problem Dimensions")->add("Global ny",A.geom->gny);
-    doc.get("Global Problem Dimensions")->add("Global nz",A.geom->gnz);
+    doc.get("Global Problem Dimensions")->add("Global nx",A.geom->npx*A.geom->nx);
+    doc.get("Global Problem Dimensions")->add("Global ny",A.geom->npy*A.geom->ny);
+    doc.get("Global Problem Dimensions")->add("Global nz",A.geom->npz*A.geom->nz);
 
     doc.add("Processor Dimensions","");
     doc.get("Processor Dimensions")->add("npx",A.geom->npx);
@@ -228,15 +250,7 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     doc.add("Local Domain Dimensions","");
     doc.get("Local Domain Dimensions")->add("nx",A.geom->nx);
     doc.get("Local Domain Dimensions")->add("ny",A.geom->ny);
-
-    int ipartz_ids = 0;
-    for (int i=0; i< A.geom->npartz; ++i) {
-      doc.get("Local Domain Dimensions")->add("Lower ipz", ipartz_ids);
-      doc.get("Local Domain Dimensions")->add("Upper ipz", A.geom->partz_ids[i]-1);
-      doc.get("Local Domain Dimensions")->add("nz",A.geom->partz_nz[i]);
-      ipartz_ids = A.geom->partz_ids[i];
-    }
-
+    doc.get("Local Domain Dimensions")->add("nz",A.geom->nz);
 
     doc.add("########## Problem Summary  ##########","");
 
@@ -252,12 +266,12 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     Af = &A;
     doc.get("Multigrid Information")->add("Coarse Grids","");
     for (int i=1; i<numberOfMgLevels; ++i) {
-      doc.get("Multigrid Information")->get("Coarse Grids")->add("Grid Level",i);
-      doc.get("Multigrid Information")->get("Coarse Grids")->add("Number of Equations",Af->Ac->totalNumberOfRows);
-      doc.get("Multigrid Information")->get("Coarse Grids")->add("Number of Nonzero Terms",Af->Ac->totalNumberOfNonzeros);
-      doc.get("Multigrid Information")->get("Coarse Grids")->add("Number of Presmoother Steps",Af->mgData->numberOfPresmootherSteps);
-      doc.get("Multigrid Information")->get("Coarse Grids")->add("Number of Postsmoother Steps",Af->mgData->numberOfPostsmootherSteps);
-      Af = Af->Ac;
+        doc.get("Multigrid Information")->get("Coarse Grids")->add("Grid Level",i);
+        doc.get("Multigrid Information")->get("Coarse Grids")->add("Number of Equations",Af->Ac->totalNumberOfRows);
+        doc.get("Multigrid Information")->get("Coarse Grids")->add("Number of Nonzero Terms",Af->Ac->totalNumberOfNonzeros);
+        doc.get("Multigrid Information")->get("Coarse Grids")->add("Number of Presmoother Steps",Af->mgData->numberOfPresmootherSteps);
+        doc.get("Multigrid Information")->get("Coarse Grids")->add("Number of Postsmoother Steps",Af->mgData->numberOfPostsmootherSteps);
+    	Af = Af->Ac;
     }
 
     doc.add("########## Memory Use Summary  ##########","");
@@ -271,8 +285,8 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
 
     doc.get("Memory Use Information")->add("Coarse Grids","");
     for (int i=1; i<numberOfMgLevels; ++i) {
-      doc.get("Memory Use Information")->get("Coarse Grids")->add("Grid Level",i);
-      doc.get("Memory Use Information")->get("Coarse Grids")->add("Memory used",fnbytesPerLevel[i]/1000000000.0);
+        doc.get("Memory Use Information")->get("Coarse Grids")->add("Grid Level",i);
+        doc.get("Memory Use Information")->get("Coarse Grids")->add("Memory used",fnbytesPerLevel[i]/1000000000.0);
     }
 
     doc.add("########## V&V Testing Summary  ##########","");
@@ -325,6 +339,7 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     doc.get("Benchmark Time Summary")->add("WAXPBY",times[2]);
     doc.get("Benchmark Time Summary")->add("SpMV",times[3]);
     doc.get("Benchmark Time Summary")->add("MG",times[5]);
+    doc.get("Benchmark Time Summary")->add("ALL_reduce",times[4]);
     doc.get("Benchmark Time Summary")->add("Total",times[0]);
 
     doc.add("Floating Point Operations Summary","");
@@ -354,9 +369,10 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     double totalGflops24 = frefnops/(times[0]+fNumberOfCgSets*times[7]/10.0)/1.0E9;
     doc.get("GFLOP/s Summary")->add("Total with convergence and optimization phase overhead",totalGflops);
 
-    doc.add("User Optimization Overheads","");
-    doc.get("User Optimization Overheads")->add("Optimization phase time (sec)", (times[7]));
-    doc.get("User Optimization Overheads")->add("Optimization phase time vs reference SpMV+MG time", times[7]/times[8]);
+  doc.add("User Optimization Overheads","");
+  doc.get("User Optimization Overheads")->add("Problem setup time (sec)", (times[9]));
+  doc.get("User Optimization Overheads")->add("Optimization phase time (sec)", (times[7]));
+  doc.get("User Optimization Overheads")->add("Optimization phase time vs reference SpMV+MG time", times[7]/times[8]);
 
 #ifndef HPCG_NO_MPI
     doc.add("DDOT Timing Variations","");
@@ -367,44 +383,47 @@ void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgS
     //doc.get("Sparse Operations Overheads")->add("Halo exchange time (sec)", (times[6]));
     //doc.get("Sparse Operations Overheads")->add("Halo exchange as percentage of SpMV time", (times[6])/totalSparseMVTime*100.0);
 #endif
-    doc.add("Final Summary","");
+    doc.add("__________ Final Summary __________","");
     bool isValidRun = (testcg_data.count_fail==0) && (testsymmetry_data.count_fail==0) && (testnorms_data.pass) && (!global_failure);
     if (isValidRun) {
-      doc.get("Final Summary")->add("HPCG result is VALID with a GFLOP/s rating of", totalGflops);
-      doc.get("Final Summary")->add("HPCG 2.4 rating for historical reasons is", totalGflops24);
+        doc.get("__________ Final Summary __________")->add("HPCG result is VALID with a GFLOP/s rating of", totalGflops);
+        doc.get("__________ Final Summary __________")->add("    HPCG 2.4 Rating (for historical value) is", totalGflops24);
+        printf("HPCG result is VALID with a GFLOP/s rating of %lf\n",totalGflops);
       if (!A.isDotProductOptimized) {
-        doc.get("Final Summary")->add("Reference version of ComputeDotProduct used","Performance results are most likely suboptimal");
+        doc.get("__________ Final Summary __________")->add("Reference version of ComputeDotProduct used","Performance results are most likely suboptimal");
       }
       if (!A.isSpmvOptimized) {
-        doc.get("Final Summary")->add("Reference version of ComputeSPMV used","Performance results are most likely suboptimal");
+        doc.get("__________ Final Summary __________")->add("Reference version of ComputeSPMV used","Performance results are most likely suboptimal");
       }
       if (!A.isMgOptimized) {
         if (A.geom->numThreads>1)
-          doc.get("Final Summary")->add("Reference version of ComputeMG used and number of threads greater than 1","Performance results are severely suboptimal");
+          doc.get("__________ Final Summary __________")->add("Reference version of ComputeMG used and number of threads greater than 1","Performance results are severely suboptimal");
         else // numThreads ==1
-          doc.get("Final Summary")->add("Reference version of ComputeMG used","Performance results are most likely suboptimal");
+          doc.get("__________ Final Summary __________")->add("Reference version of ComputeMG used","Performance results are most likely suboptimal");
       }
       if (!A.isWaxpbyOptimized) {
-        doc.get("Final Summary")->add("Reference version of ComputeWAXPBY used","Performance results are most likely suboptimal");
+        doc.get("__________ Final Summary __________")->add("Reference version of ComputeWAXPBY used","Performance results are most likely suboptimal");
       }
       if (times[0]>=minOfficialTime) {
-        doc.get("Final Summary")->add("Please upload results from the YAML file contents to","http://hpcg-benchmark.org");
+        doc.get("__________ Final Summary __________")->add("Please upload results from the YAML file contents to","http://hpcg-benchmark.org");
       }
       else {
-        doc.get("Final Summary")->add("Results are valid but execution time (sec) is",times[0]);
-        if (quickPath) {
-          doc.get("Final Summary")->add("You have selected the QuickPath option", "Results are official for legacy installed systems with confirmation from the HPCG Benchmark leaders.");
-          doc.get("Final Summary")->add("After confirmation please upload results from the YAML file contents to","http://hpcg-benchmark.org");
-        } else {
-          doc.get("Final Summary")->add("Official results execution time (sec) must be at least",minOfficialTime);
-        }
+          doc.get("__________ Final Summary __________")->add("Results are valid but execution time (sec) is",times[0]);
+          if (quickPath) {
+        	  doc.get("__________ Final Summary __________")->add("     You have selected the QuickPath option", "Results are official for legacy installed systems with confirmation from the HPCG Benchmark leaders.");
+              doc.get("__________ Final Summary __________")->add("     After confirmation please upload results from the YAML file contents to","http://hpcg-benchmark.org");
+
+          }
+          else {
+        	  doc.get("__________ Final Summary __________")->add("     Official results execution time (sec) must be at least",minOfficialTime);
+          }
       }
     } else {
-      doc.get("Final Summary")->add("HPCG result is","INVALID.");
-      doc.get("Final Summary")->add("Please review the YAML file contents","You may NOT submit these results for consideration.");
+      doc.get("__________ Final Summary __________")->add("HPCG result is","INVALID.");
+      doc.get("__________ Final Summary __________")->add("Please review the YAML file contents","You may NOT submit these results for consideration.");
     }
 
-    std::string yaml = doc.generate();
+    std::string yaml = doc.generateYAML();
 #ifdef HPCG_DEBUG
     HPCG_fout << yaml;
 #endif
diff --git a/src/ReportResults.hpp b/src/ReportResults.hpp
index 43561a4..f0e42e5 100644
--- a/src/ReportResults.hpp
+++ b/src/ReportResults.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -20,6 +33,6 @@
 #include "TestNorms.hpp"
 
 void ReportResults(const SparseMatrix & A, int numberOfMgLevels, int numberOfCgSets, int refMaxIters, int optMaxIters, double times[],
-    const TestCGData & testcg_data, const TestSymmetryData & testsymmetry_data, const TestNormsData & testnorms_data, int global_failure, bool quickPath);
+    const TestCGData & testcg_data, const TestSymmetryData & testsymmetry_data, const TestNormsData & testnorms_data, int global_failure, bool quickPath, const HPCG_Params& params);
 
 #endif // REPORTRESULTS_HPP
diff --git a/src/SetupHalo.cpp b/src/SetupHalo.cpp
index 427c7cd..66bdc62 100644
--- a/src/SetupHalo.cpp
+++ b/src/SetupHalo.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -39,11 +52,230 @@
 
   @see ExchangeHalo
 */
-void SetupHalo(SparseMatrix & A) {
 
-  // The call to this reference version of SetupHalo can be replaced with custom code.
-  // However, any code must work for general unstructured sparse matrices.  Special knowledge about the
-  // specific nature of the sparsity pattern may not be explicitly used.
+void SetupHalo(SparseMatrix & A)
+{
+    if( A.geom->size > 1 )
+    {
+        local_int_t localNumberOfRows = A.localNumberOfRows;
+        char  * nonzerosInRow = A.nonzerosInRow;
+        global_int_t ** mtxIndG = A.mtxIndG;
+        local_int_t ** mtxIndL = A.mtxIndL;
+        double t1 = 0;
 
-  return(SetupHalo_ref(A));
+        int nproc = A.nproc;
+        nproc = (nproc > A.numOfBoundaryRows) ? A.numOfBoundaryRows : nproc;
+
+        local_int_t totalToBeSent = 0, totalToBeReceived = 0, cnt = 0;
+        local_int_t number_of_neighbors = A.numberOfSendNeighbors;
+        local_int_t *receiveLength = NULL, *sendLength = NULL, *map_neib_s = NULL;
+        local_int_t *map_neib_r = A.work, *neighbors = NULL;
+        global_int_t *map_send = NULL;
+
+        double *sendBuffer = NULL;
+        local_int_t  *elementsToSend   = NULL, *all_send = NULL, *all_recv = NULL;
+        global_int_t *elementsToSend_G = NULL, *elementsToRecv_G = NULL;
+        std::map< local_int_t, local_int_t > externalToLocalMap;
+        local_int_t receiveEntryCount = 0, sendEntryCount = 0;
+
+        map_send      = (global_int_t*) MKL_malloc( sizeof(global_int_t)*A.numOfBoundaryRows*number_of_neighbors, 512 );
+        map_neib_s    = (local_int_t *) MKL_malloc( sizeof(local_int_t )*A.geom->size                           , 512 );
+        neighbors     = (local_int_t *) MKL_malloc( sizeof(local_int_t )*number_of_neighbors                    , 512 );
+        receiveLength = (local_int_t *) MKL_malloc( sizeof(local_int_t )*number_of_neighbors                    , 512 );
+        sendLength    = (local_int_t *) MKL_malloc( sizeof(local_int_t )*number_of_neighbors                    , 512 );
+
+        if ( map_neib_s == NULL || map_send == NULL || neighbors == NULL || receiveLength == NULL || sendLength == NULL ) return;
+
+        for ( local_int_t i = 0; i < A.geom->size; i ++ ) map_neib_s[i] = 0;
+
+        for ( local_int_t i = 0; i < A.geom->size; i ++ )
+        {
+            if ( map_neib_r[i] > 0 )
+            {
+                neighbors[cnt] = i;
+                map_neib_s[i] = cnt++;
+            }
+        }
+#ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for num_threads(nproc)
+#endif
+        for ( local_int_t i = 0; i < A.numOfBoundaryRows*number_of_neighbors;    i ++ ) map_send[i] = -1;
+
+        for ( local_int_t i = 0; i < number_of_neighbors; i ++)
+        {
+            receiveLength[i] = 0;
+            sendLength[i] = 0;
+        }
+#ifndef HPCG_NO_OPENMP        
+        #pragma omp parallel for reduction(+:totalToBeSent)
+#endif
+        for ( local_int_t row = 0; row < A.numOfBoundaryRows; row++ )
+        {
+            local_int_t i = A.boundaryRows[row];
+            for ( local_int_t j = 0; j < nonzerosInRow[i]; j++ )
+            {
+                if( mtxIndL[i][j] < 0 )
+                {
+                    global_int_t curIndex = mtxIndG[i][j];
+                    int rankIdOfColumnEntry = ComputeRankOfMatrixRow(*(A.geom), curIndex);
+                    local_int_t jj = map_neib_s[rankIdOfColumnEntry];
+
+                    if ( map_send[jj*A.numOfBoundaryRows + row] < 0 )
+                    {
+                        map_send[jj*A.numOfBoundaryRows + row] = A.localToGlobalMap[i];
+                        totalToBeSent++;
+                    }
+                }
+            }
+        }
+        sendBuffer       = (double      *) MKL_malloc(sizeof(double      )*totalToBeSent, 512);
+        elementsToSend   = (local_int_t *) MKL_malloc(sizeof(local_int_t )*totalToBeSent, 512);
+        elementsToSend_G = (global_int_t*) MKL_malloc(sizeof(global_int_t)*totalToBeSent, 512);
+
+        if ( sendBuffer == NULL || elementsToSend == NULL || elementsToSend_G == NULL ) return;
+
+        for ( local_int_t i = 0; i < number_of_neighbors; i ++ )
+        {
+            for ( local_int_t j = 0; j < A.numOfBoundaryRows; j ++)
+            {
+                global_int_t ind = map_send[i*A.numOfBoundaryRows + j];
+                if ( ind >= 0 )
+                {
+                    elementsToSend_G[sendEntryCount] = ind;
+                    sendLength[i] ++;
+                    sendEntryCount++;
+                }
+            }
+        }
+
+        all_send = (local_int_t *) MKL_malloc(sizeof(local_int_t )*A.geom->size, 512);
+        all_recv = (local_int_t *) MKL_malloc(sizeof(local_int_t )*A.geom->size, 512);
+
+        if ( all_send == NULL || all_recv == NULL ) return;
+
+        for( local_int_t i = 0 ; i < A.geom->size; i++ ) { all_send[i] = 0; all_recv[i] = 0; }
+        for (int i = 0; i < number_of_neighbors; i++)
+        {
+            all_send[ neighbors[i] ] = sendLength[i];
+        }
+        MPI_Alltoall( all_send, 1, MPI_INT, all_recv, 1, MPI_INT, MPI_COMM_WORLD );
+        local_int_t totalToBeRecv = 0;
+        for (int i = 0; i < number_of_neighbors; i++)
+        {
+            receiveLength[ i ] = all_recv[ neighbors[i] ];
+            totalToBeRecv += receiveLength[ i ];
+        }
+        elementsToRecv_G = (global_int_t*) MKL_malloc(sizeof(global_int_t)*totalToBeRecv, 512);
+
+        if ( elementsToRecv_G == NULL ) return;
+
+        int MPI_MY_TAG = 98;
+
+        MPI_Request *request = (MPI_Request*) MKL_malloc(sizeof(MPI_Request)*number_of_neighbors, 512);
+
+        if (request == NULL ) return;
+
+        global_int_t *elementsToRecv_pt = elementsToRecv_G;
+
+        for (int i = 0; i < number_of_neighbors; i++) {
+            local_int_t n_recv = receiveLength[i];
+            MPI_Irecv(elementsToRecv_pt, n_recv, MPI_LONG_LONG_INT, neighbors[i], MPI_MY_TAG, MPI_COMM_WORLD, request+i);
+            elementsToRecv_pt += n_recv;
+        }
+        global_int_t *elementsToSend_pt = elementsToSend_G;
+        for (int i = 0; i < number_of_neighbors; i++) {
+            local_int_t n_send = sendLength[i];
+            MPI_Send(elementsToSend_pt, n_send, MPI_LONG_LONG_INT, neighbors[i], MPI_MY_TAG, MPI_COMM_WORLD);
+            elementsToSend_pt += n_send;
+        }
+        MPI_Status status;
+        for (int i = 0; i < number_of_neighbors; i++) {
+            if ( MPI_Wait(request+i, &status) ) {
+                std::exit(-1); // TODO: have better error exit
+            }
+        }
+#ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+#endif
+        for( local_int_t i = 0; i < totalToBeSent; i++ )
+        {
+            elementsToSend[ i ] = A.globalToLocalMap[ elementsToSend_G[ i ] ];
+        }
+
+        receiveEntryCount = 0;
+        for (local_int_t i = 0; i < number_of_neighbors; i++)
+        {
+            for( local_int_t j = 0; j < receiveLength[i]; j ++, receiveEntryCount++ ) 
+            {
+                externalToLocalMap[elementsToRecv_G[receiveEntryCount]] = localNumberOfRows + receiveEntryCount; 
+            }
+        }
+#ifndef HPCG_NO_OPENMP
+        #pragma omp parallel for
+#endif
+        for ( local_int_t row = 0; row < A.numOfBoundaryRows; row++ )
+        {
+            local_int_t i = A.boundaryRows[row];
+            for ( local_int_t j = 0; j < nonzerosInRow[i]; j++ )
+            {
+                if ( mtxIndL[i][j] < 0 ) // My column index, so convert to local index
+                {
+                    global_int_t curIndex = mtxIndG[i][j];
+                    mtxIndL[i][j] = externalToLocalMap[curIndex];
+                }
+            }
+        }
+
+        local_int_t *sdispls = (local_int_t*) MKL_malloc( sizeof(local_int_t)*A.geom->size, 128 );
+        local_int_t *rdispls = (local_int_t*) MKL_malloc( sizeof(local_int_t)*A.geom->size, 128 );
+        local_int_t *scounts = (local_int_t*) MKL_malloc( sizeof(local_int_t)*A.geom->size, 128 );
+        local_int_t *rcounts = (local_int_t*) MKL_malloc( sizeof(local_int_t)*A.geom->size, 128 );
+        local_int_t tmp_s = 0, tmp_r = 0;
+
+        if(sdispls == NULL || rdispls == NULL || scounts == NULL || rcounts == NULL) return;
+
+        for( local_int_t i = 0; i < A.geom->size; i++ )
+        {
+            scounts[i] = 0;
+            rcounts[i] = 0;
+            sdispls[i] = 0;
+            rdispls[i] = 0;
+        }
+        for( local_int_t i = 0; i < number_of_neighbors; i++ )
+        {
+            local_int_t root = neighbors[i];
+            scounts[root] = sendLength[i];
+            rcounts[root] = receiveLength[i];
+            sdispls[root] = tmp_s; tmp_s+=sendLength[i];
+            rdispls[root] = tmp_r; tmp_r+=receiveLength[i];
+        }
+        A.scounts = scounts;
+        A.rcounts = rcounts;
+        A.sdispls = sdispls;
+        A.rdispls = rdispls;
+
+        A.numberOfExternalValues = externalToLocalMap.size();
+        A.localNumberOfColumns = A.localNumberOfRows + A.numberOfExternalValues;
+        A.numberOfSendNeighbors = number_of_neighbors;
+        A.totalToBeSent = totalToBeSent;
+        A.elementsToSend = elementsToSend;
+        A.neighbors = neighbors;
+        A.receiveLength = receiveLength;
+        A.sendLength = sendLength;
+        A.sendBuffer = sendBuffer;
+
+        MKL_free(map_send);
+        MKL_free(map_neib_s);
+        MKL_free(elementsToSend_G);
+        MKL_free(all_send);
+        MKL_free(all_recv);
+        MKL_free(elementsToRecv_G);
+        MKL_free(request);
+    } else {
+        A.numberOfExternalValues = 0;
+        A.localNumberOfColumns = A.localNumberOfRows;
+        A.numberOfSendNeighbors = 0;
+        A.totalToBeSent = 0;
+        A.elementsToSend = 0;
+    }
 }
diff --git a/src/SetupHalo.hpp b/src/SetupHalo.hpp
index 60635cd..53e57ea 100644
--- a/src/SetupHalo.hpp
+++ b/src/SetupHalo.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/SetupHalo_ref.cpp b/src/SetupHalo_ref.cpp
index 5cad734..0e7eb66 100644
--- a/src/SetupHalo_ref.cpp
+++ b/src/SetupHalo_ref.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -55,7 +68,9 @@ void SetupHalo_ref(SparseMatrix & A) {
   global_int_t ** mtxIndG = A.mtxIndG;
   local_int_t ** mtxIndL = A.mtxIndL;
 
-#ifdef HPCG_NO_MPI  // In the non-MPI case we simply copy global indices to local index storage
+//#ifdef HPCG_NO_MPI  // In the non-MPI case we simply copy global indices to local index storage
+#if 0
+/*
 #ifndef HPCG_NO_OPENMP
   #pragma omp parallel for
 #endif
@@ -63,7 +78,20 @@ void SetupHalo_ref(SparseMatrix & A) {
     int cur_nnz = nonzerosInRow[i];
     for (int j=0; j<cur_nnz; j++) mtxIndL[i][j] = mtxIndG[i][j];
   }
-
+  
+  for( int i=0; i<localNumberOfRows; i++ )
+  {
+    double sum = 0.0;
+    const double * const cur_vals = A.matrixValues[i];
+    const local_int_t * const cur_inds = A.mtxIndL[i];
+    const int cur_nnz = A.nonzerosInRow[i];
+    printf("%d: ",i);
+    for (int j=0; j< cur_nnz; j++)
+        printf(" %1.2f %d ",cur_vals[j],cur_inds[j]);
+        printf("\n");fflush(0);
+  }
+  abort();
+  */
 #else // Run this section if compiling for MPI
 
   // Scan global IDs of the nonzeros in the matrix.  Determine if the column ID matches a row ID.  If not:
diff --git a/src/SetupHalo_ref.hpp b/src/SetupHalo_ref.hpp
index 443e2dc..25573f8 100644
--- a/src/SetupHalo_ref.hpp
+++ b/src/SetupHalo_ref.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/SparseMatrix.hpp b/src/SparseMatrix.hpp
index 93d1f67..f2c4d83 100644
--- a/src/SparseMatrix.hpp
+++ b/src/SparseMatrix.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -20,21 +33,31 @@
 
 #ifndef SPARSEMATRIX_HPP
 #define SPARSEMATRIX_HPP
+#define MKL
 
+#include <map>
 #include <vector>
 #include <cassert>
 #include "Geometry.hpp"
 #include "Vector.hpp"
 #include "MGData.hpp"
-#if __cplusplus <= 201103L
-// for C++03
-#include <map>
-typedef std::map< global_int_t, local_int_t > GlobalToLocalMap;
-#else
-// for C++11 or greater
-#include <unordered_map>
-using GlobalToLocalMap = std::unordered_map< global_int_t, local_int_t >;
-#endif
+
+#include "mkl_spblas.h"
+#include "mkl_service.h"
+#include "stdio.h"
+
+struct optData
+{
+    double *diag;
+    double *dtmp;
+    double *dtmp2;
+    double *dtmp3;
+    double *dtmp4;
+    local_int_t nrow_b;
+    local_int_t *bmap;
+    void *csrA;
+    void *csrB;
+};
 
 struct SparseMatrix_STRUCT {
   char  * title; //!< name of the sparse matrix
@@ -49,7 +72,7 @@ struct SparseMatrix_STRUCT {
   local_int_t ** mtxIndL; //!< matrix indices as local values
   double ** matrixValues; //!< values of matrix entries
   double ** matrixDiagonal; //!< values of matrix diagonal entries
-  GlobalToLocalMap globalToLocalMap; //!< global-to-local mapping
+  std::map< global_int_t, local_int_t > globalToLocalMap; //!< global-to-local mapping
   std::vector< global_int_t > localToGlobalMap; //!< local-to-global mapping
   mutable bool isDotProductOptimized;
   mutable bool isSpmvOptimized;
@@ -73,6 +96,17 @@ struct SparseMatrix_STRUCT {
   local_int_t * sendLength; //!< lenghts of messages sent to neighboring processes
   double * sendBuffer; //!< send buffer for non-blocking sends
 #endif
+  local_int_t * boundaryRows; //!< rows that contain less than 27 nonzeros
+  local_int_t numOfBoundaryRows;
+  local_int_t *mtxL;
+  global_int_t *mtxG;
+  double *mtxA;
+  local_int_t nproc;
+  local_int_t *work;
+  local_int_t *scounts;
+  local_int_t *rcounts;
+  local_int_t *sdispls;
+  local_int_t *rdispls;
 };
 typedef struct SparseMatrix_STRUCT SparseMatrix;
 
@@ -94,6 +128,9 @@ inline void InitializeSparseMatrix(SparseMatrix & A, Geometry * geom) {
   A.mtxIndL = 0;
   A.matrixValues = 0;
   A.matrixDiagonal = 0;
+  A.boundaryRows = 0;
+  A.numOfBoundaryRows = 0;
+  A.nproc = 1;
 
   // Optimization is ON by default. The code that switches it OFF is in the
   // functions that are meant to be optimized.
@@ -114,6 +151,8 @@ inline void InitializeSparseMatrix(SparseMatrix & A, Geometry * geom) {
 #endif
   A.mgData = 0; // Fine-to-coarse grid transfer initially not defined.
   A.Ac =0;
+  
+  A.optimizationData=NULL;
   return;
 }
 
@@ -124,10 +163,17 @@ inline void InitializeSparseMatrix(SparseMatrix & A, Geometry * geom) {
   @param[inout] diagonal  Vector of diagonal values (must be allocated before call to this function).
  */
 inline void CopyMatrixDiagonal(SparseMatrix & A, Vector & diagonal) {
+#if 1
+    SparseMatrix *Ac = &A;
+    struct optData *optData = (struct optData *)Ac->optimizationData;
+    double * dv = diagonal.values;
+    for (local_int_t i=0; i<A.localNumberOfRows; ++i) dv[i] = optData->diag[i];
+#else
     double ** curDiagA = A.matrixDiagonal;
     double * dv = diagonal.values;
     assert(A.localNumberOfRows==diagonal.localLength);
     for (local_int_t i=0; i<A.localNumberOfRows; ++i) dv[i] = *(curDiagA[i]);
+#endif
   return;
 }
 /*!
@@ -143,43 +189,76 @@ inline void ReplaceMatrixDiagonal(SparseMatrix & A, Vector & diagonal) {
     for (local_int_t i=0; i<A.localNumberOfRows; ++i) *(curDiagA[i]) = dv[i];
   return;
 }
+
+inline void ReplaceMKLMatrixDiagonal(SparseMatrix & A, Vector & diagonal)
+{
+    SparseMatrix *Ac = &A;
+    struct optData *optData = (struct optData *)Ac->optimizationData;
+    sparse_status_t stat = SPARSE_STATUS_SUCCESS;
+    sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+
+    for(local_int_t i=0; i<Ac->localNumberOfRows; i++)
+    {
+        stat = mkl_sparse_d_set_value(csrA, i, i, diagonal.values[i]);
+        optData->diag[i] = diagonal.values[i];
+    }
+}
 /*!
   Deallocates the members of the data structure of the known system matrix provided they are not 0.
 
   @param[in] A the known system matrix
  */
 inline void DeleteMatrix(SparseMatrix & A) {
-
-#ifndef HPCG_CONTIGUOUS_ARRAYS
-  for (local_int_t i = 0; i< A.localNumberOfRows; ++i) {
-    delete [] A.matrixValues[i];
-    delete [] A.mtxIndG[i];
-    delete [] A.mtxIndL[i];
-  }
-#else
-  delete [] A.matrixValues[0];
-  delete [] A.mtxIndG[0];
-  delete [] A.mtxIndL[0];
-#endif
   if (A.title)                  delete [] A.title;
-  if (A.nonzerosInRow)             delete [] A.nonzerosInRow;
-  if (A.mtxIndG) delete [] A.mtxIndG;
-  if (A.mtxIndL) delete [] A.mtxIndL;
-  if (A.matrixValues) delete [] A.matrixValues;
-  if (A.matrixDiagonal)           delete [] A.matrixDiagonal;
+  if (A.nonzerosInRow) { MKL_free(A.nonzerosInRow); A.nonzerosInRow  = NULL; }
+  if (A.matrixDiagonal){ MKL_free(A.matrixDiagonal);A.matrixDiagonal = NULL; }
+  if (A.boundaryRows)  { MKL_free( A.boundaryRows) ;A.boundaryRows   = NULL; }
 
 #ifndef HPCG_NO_MPI
+  /*
   if (A.elementsToSend)       delete [] A.elementsToSend;
   if (A.neighbors)              delete [] A.neighbors;
   if (A.receiveLength)            delete [] A.receiveLength;
   if (A.sendLength)            delete [] A.sendLength;
   if (A.sendBuffer)            delete [] A.sendBuffer;
+  */
+  MKL_free(A.elementsToSend);
+  MKL_free(A.neighbors);
+  MKL_free(A.receiveLength);
+  MKL_free(A.sendLength);
+  MKL_free(A.sendBuffer);
 #endif
 
-  if (A.geom!=0) { DeleteGeometry(*A.geom); delete A.geom; A.geom = 0;}
+  struct optData *optData = (struct optData *)A.optimizationData;
+  if ( optData != NULL )
+  {
+      MKL_free(optData->dtmp);
+      MKL_free(optData->bmap);
+      MKL_free(optData->diag);
+
+      sparse_matrix_t csrA = (sparse_matrix_t)optData->csrA;
+      sparse_matrix_t csrB = (sparse_matrix_t)optData->csrB;
+      mkl_sparse_destroy(csrA);
+      mkl_sparse_destroy(csrB);
+      MKL_free(optData);
+  }
+
+  if (A.geom!=0) { delete A.geom; A.geom = 0;}
   if (A.Ac!=0) { DeleteMatrix(*A.Ac); delete A.Ac; A.Ac = 0;} // Delete coarse matrix
   if (A.mgData!=0) { DeleteMGData(*A.mgData); delete A.mgData; A.mgData = 0;} // Delete MG data
   return;
 }
 
+inline void init_optData(struct optData optData)
+{
+    optData.dtmp  = NULL;
+    optData.dtmp2 = NULL;
+    optData.dtmp3 = NULL;
+    optData.dtmp4 = NULL;
+    optData.diag  = NULL;
+    optData.csrA  = NULL;
+    optData.csrB  = NULL;
+    optData.bmap  = NULL;
+}
+
 #endif // SPARSEMATRIX_HPP
diff --git a/src/TestCG.cpp b/src/TestCG.cpp
index 8365f61..108490e 100644
--- a/src/TestCG.cpp
+++ b/src/TestCG.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -51,7 +64,6 @@ using std::endl;
  */
 int TestCG(SparseMatrix & A, CGData & data, Vector & b, Vector & x, TestCGData & testcg_data) {
 
-
   // Use this array for collecting timing information
   std::vector< double > times(8,0.0);
   // Temporary storage for holding original diagonal and RHS
@@ -76,7 +88,12 @@ int TestCG(SparseMatrix & A, CGData & data, Vector & b, Vector & x, TestCGData &
       ScaleVectorValue(b, i, 1.0e6);
     }
   }
-  ReplaceMatrixDiagonal(A, exaggeratedDiagA);
+//#ifdef MKL
+  ReplaceMKLMatrixDiagonal(A, exaggeratedDiagA);
+//#else
+//  ReplaceMatrixDiagonal(A, exaggeratedDiagA);
+//#endif
+
 
   int niters = 0;
   double normr = 0.0;
@@ -110,11 +127,18 @@ int TestCG(SparseMatrix & A, CGData & data, Vector & b, Vector & x, TestCGData &
     }
   }
 
+
   // Restore matrix diagonal and RHS
-  ReplaceMatrixDiagonal(A, origDiagA);
+//#ifdef MKL
+  ReplaceMKLMatrixDiagonal(A, origDiagA);
+//#else
+//  ReplaceMatrixDiagonal(A, origDiagA);
+//#endif
+
+
   CopyVector(origB, b);
   // Delete vectors
-  DeleteVector(origDiagA);
+  DeleteVector(origDiagA); 
   DeleteVector(exaggeratedDiagA);
   DeleteVector(origB);
   testcg_data.normr = normr;
diff --git a/src/TestCG.hpp b/src/TestCG.hpp
index fa2eaa3..ee2d50b 100644
--- a/src/TestCG.hpp
+++ b/src/TestCG.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/TestNorms.cpp b/src/TestNorms.cpp
index 5a9f8f3..def27f0 100644
--- a/src/TestNorms.cpp
+++ b/src/TestNorms.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/TestNorms.hpp b/src/TestNorms.hpp
index 3641c6d..672d4bb 100644
--- a/src/TestNorms.hpp
+++ b/src/TestNorms.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/TestSymmetry.cpp b/src/TestSymmetry.cpp
index 4f49473..6b8f03e 100644
--- a/src/TestSymmetry.cpp
+++ b/src/TestSymmetry.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -32,7 +45,9 @@ using std::endl;
 #include "hpcg.hpp"
 
 #include "ComputeSPMV.hpp"
+#include "ComputeSPMV_ref.hpp"
 #include "ComputeMG.hpp"
+#include "ComputeMG_ref.hpp"
 #include "ComputeDotProduct.hpp"
 #include "ComputeResidual.hpp"
 #include "Geometry.hpp"
@@ -40,7 +55,8 @@ using std::endl;
 #include "TestSymmetry.hpp"
 
 /*!
-  Tests symmetry-preserving properties of the sparse matrix vector multiply and multi-grid routines.
+  Tests symmetry-preserving properties of the sparse matrix vector multiply and
+  symmetric Gauss-Siedel routines.
 
   @param[in]    geom   The description of the problem's geometry.
   @param[in]    A      The known system matrix
@@ -99,7 +115,7 @@ int TestSymmetry(SparseMatrix & A, Vector & b, Vector & xexact, TestSymmetryData
  if (testsymmetry_data.depsym_spmv > 1.0) ++testsymmetry_data.count_fail;  // If the difference is > 1, count it wrong
  if (A.geom->rank==0) HPCG_fout << "Departure from symmetry (scaled) for SpMV abs(x'*A*y - y'*A*x) = " << testsymmetry_data.depsym_spmv << endl;
 
- // Test symmetry of multi-grid
+ // Test symmetry of symmetric Gauss-Seidel
 
  // Compute x'*Minv*y
  ierr = ComputeMG(A, y_ncol, z_ncol); // z_ncol = Minv*y_ncol
diff --git a/src/TestSymmetry.hpp b/src/TestSymmetry.hpp
index 1bd079d..f650f3c 100644
--- a/src/TestSymmetry.hpp
+++ b/src/TestSymmetry.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -27,7 +40,7 @@
 
 struct TestSymmetryData_STRUCT {
   double depsym_spmv;  //!< departure from symmetry for the SPMV kernel
-  double depsym_mg; //!< departure from symmetry for the MG kernel
+  double depsym_mg; //!< departure from symmetry for the SYMGS kernel
   int    count_fail;   //!< number of failures in the symmetry tests
 };
 typedef struct TestSymmetryData_STRUCT TestSymmetryData;
diff --git a/src/Vector.hpp b/src/Vector.hpp
index b8140c8..2f7f268 100644
--- a/src/Vector.hpp
+++ b/src/Vector.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -22,6 +35,7 @@
 #define VECTOR_HPP
 #include <cassert>
 #include <cstdlib>
+#include "mkl.h"
 #include "Geometry.hpp"
 
 struct Vector_STRUCT {
@@ -44,7 +58,7 @@ typedef struct Vector_STRUCT Vector;
  */
 inline void InitializeVector(Vector & v, local_int_t localLength) {
   v.localLength = localLength;
-  v.values = new double[localLength];
+  v.values = (double*) MKL_malloc(sizeof(double)*localLength, 512); //new double[localLength];
   v.optimizationData = 0;
   return;
 }
@@ -57,6 +71,9 @@ inline void InitializeVector(Vector & v, local_int_t localLength) {
 inline void ZeroVector(Vector & v) {
   local_int_t localLength = v.localLength;
   double * vv = v.values;
+#ifndef HPCG_NO_OPENMP
+  #pragma omp parallel for
+#endif
   for (int i=0; i<localLength; ++i) vv[i] = 0.0;
   return;
 }
@@ -95,6 +112,9 @@ inline void CopyVector(const Vector & v, Vector & w) {
   assert(w.localLength >= localLength);
   double * vv = v.values;
   double * wv = w.values;
+#ifndef HPCG_NO_OPENMP
+  #pragma omp parallel for
+#endif
   for (int i=0; i<localLength; ++i) wv[i] = vv[i];
   return;
 }
@@ -107,7 +127,8 @@ inline void CopyVector(const Vector & v, Vector & w) {
  */
 inline void DeleteVector(Vector & v) {
 
-  delete [] v.values;
+  //delete [] v.values;
+  MKL_free(v.values);
   v.localLength = 0;
   return;
 }
diff --git a/src/WriteProblem.cpp b/src/WriteProblem.cpp
index 19b30b2..e848279 100644
--- a/src/WriteProblem.cpp
+++ b/src/WriteProblem.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/WriteProblem.hpp b/src/WriteProblem.hpp
index 8b7849a..bd50194 100644
--- a/src/WriteProblem.hpp
+++ b/src/WriteProblem.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/YAML_Doc.cpp b/src/YAML_Doc.cpp
index 361970f..ac996f3 100644
--- a/src/YAML_Doc.cpp
+++ b/src/YAML_Doc.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -63,11 +76,16 @@ string YAML_Doc::generateYAML() {
       ptm->tm_mday, ptm->tm_hour, ptm->tm_min,ptm->tm_sec);
 
   string filename;
-  if (destinationFileName=="")
+  if (destinationFileName=="") {
     filename = miniAppName + "-" + miniAppVersion + "_";
-  else
+    filename = filename + string(sdate) + ".yaml";
+  }
+  else {
     filename = destinationFileName;
-  filename = filename + string(sdate) + ".yaml";
+    filename = filename + ".yaml";
+  }
+  
+
   if (destinationDirectory!="" && destinationDirectory!=".") {
     string mkdir_cmd = "mkdir " + destinationDirectory;
     system(mkdir_cmd.c_str());
diff --git a/src/YAML_Doc.hpp b/src/YAML_Doc.hpp
index 7661f4f..855907a 100644
--- a/src/YAML_Doc.hpp
+++ b/src/YAML_Doc.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -34,7 +47,7 @@
 
 /*!
 
-The YAML_Doc class works in conjunction with the YAML_Element class to facilitate easy collecting and reporting of YAML-formatted
+The YAML_Doc class works in conjuction with the YAML_Element class to facilitate easy collecting and reporting of YAML-formatted
 data that can be then registered with the HPCG results collection website.
 
 \code
@@ -91,7 +104,7 @@ public:
     and file name information for results that are generated by the generateYAML() method.
     \param miniApp_Name (in) string containing name of the mini-application
     \param miniApp_Version (in) string containing the version of the mini-application
-    \param destination_Directory (in, optional) path of directory where results file will be stored, relative to current working directory.
+    \param destination_Directory (in, optional) path of diretory where results file will be stored, relative to current working directory.
            If this value is not supplied, the results file will be stored in the current working directory.  If the directory does not exist
      it will be created.
     \param destination_FileName (in, optional) root name of the results file.  A suffix of ".yaml" will be automatically appended.  If no
diff --git a/src/YAML_Element.cpp b/src/YAML_Element.cpp
index c1a4ae2..d187057 100644
--- a/src/YAML_Element.cpp
+++ b/src/YAML_Element.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/YAML_Element.hpp b/src/YAML_Element.hpp
index 3955c5c..f5fcbf7 100644
--- a/src/YAML_Element.hpp
+++ b/src/YAML_Element.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/finalize.cpp b/src/finalize.cpp
index a60c75b..5b1600d 100644
--- a/src/finalize.cpp
+++ b/src/finalize.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/hpcg.hpp b/src/hpcg.hpp
index df4c9d7..61180b5 100644
--- a/src/hpcg.hpp
+++ b/src/hpcg.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -22,7 +35,9 @@
 #define HPCG_HPP
 
 #include <fstream>
-#include "Geometry.hpp"
+
+//#define DBL_EPSILON 2.2204460492503131E-16
+#define fabs_hpcg(a) ((a) >= 0.0) ? (a) : -(a)
 
 extern std::ofstream HPCG_fout;
 
@@ -30,16 +45,13 @@ struct HPCG_Params_STRUCT {
   int comm_size; //!< Number of MPI processes in MPI_COMM_WORLD
   int comm_rank; //!< This process' MPI rank in the range [0 to comm_size - 1]
   int numThreads; //!< This process' number of threads
-  local_int_t nx; //!< Number of processes in x-direction of 3D process grid
-  local_int_t ny; //!< Number of processes in y-direction of 3D process grid
-  local_int_t nz; //!< Number of processes in z-direction of 3D process grid
+  int nx; //!< Number of x-direction grid points for each local subdomain
+  int ny; //!< Number of y-direction grid points for each local subdomain
+  int nz; //!< Number of z-direction grid points for each local subdomain
   int runningTime; //!< Number of seconds to run the timed portion of the benchmark
-  int npx; //!< Number of x-direction grid points for each local subdomain
-  int npy; //!< Number of y-direction grid points for each local subdomain
-  int npz; //!< Number of z-direction grid points for each local subdomain
-  int pz; //!< Partition in the z processor dimension, default is npz
-  local_int_t zl; //!< nz for processors in the z dimension with value less than pz
-  local_int_t zu; //!< nz for processors in the z dimension with value greater than pz
+  int runRealRef;  // default true, turn on reference implementation
+  char yamlFileName[1024];
+ 
 };
 /*!
   HPCG_Params is a shorthand for HPCG_Params_STRUCT
diff --git a/src/init.cpp b/src/init.cpp
index 05958f8..d780bd4 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -28,7 +41,6 @@ const char* NULLDEVICE="/dev/null";
 
 #include <ctime>
 #include <cstdio>
-#include <cstdlib>
 #include <cstring>
 
 #include <fstream>
@@ -48,6 +60,7 @@ startswith(const char * s, const char * prefix) {
   return 1;
 }
 
+
 /*!
   Initializes an HPCG run by obtaining problem parameters (from a file or
   command line) and then broadcasts them to all nodes. It also initializes
@@ -69,35 +82,62 @@ HPCG_Init(int * argc_p, char ** *argv_p, HPCG_Params & params) {
   int argc = *argc_p;
   char ** argv = *argv_p;
   char fname[80];
-  int i, j, *iparams;
-  char cparams[][7] = {"--nx=", "--ny=", "--nz=", "--rt=", "--pz=", "--zl=", "--zu=", "--npx=", "--npy=", "--npz="};
+  int i, j, iparams[4];
+  char cparams[4][6] = {"--nx=", "--ny=", "--nz=", "-t"};
   time_t rawtime;
   tm * ptm;
-  const int nparams = (sizeof cparams) / (sizeof cparams[0]);
-  bool broadcastParams = false; // Make true if parameters read from file.
-
-  iparams = (int *)malloc(sizeof(int) * nparams);
-
+  params.runRealRef = 1;
+  params.yamlFileName[0]='\0';
   // Initialize iparams
-  for (i = 0; i < nparams; ++i) iparams[i] = 0;
+  for (i = 0; i < 4; ++i) iparams[i] = 0;
 
   /* for sequential and some MPI implementations it's OK to read first three args */
-  for (i = 0; i < nparams; ++i)
+  for (i = 0; i < 4; ++i)
     if (argc <= i+1 || sscanf(argv[i+1], "%d", iparams+i) != 1 || iparams[i] < 10) iparams[i] = 0;
 
   /* for some MPI environments, command line arguments may get complicated so we need a prefix */
   for (i = 1; i <= argc && argv[i]; ++i)
-    for (j = 0; j < nparams; ++j)
+    for (j = 0; j < 4; ++j)
       if (startswith(argv[i], cparams[j]))
-        if (sscanf(argv[i]+strlen(cparams[j]), "%d", iparams+j) != 1)
-          iparams[j] = 0;
+        if (sscanf(argv[i]+strlen(cparams[j]), "%d", iparams+j) != 1 || iparams[j] < 10) iparams[j] = 0;
+
+  /*Check for run-real-ref*/
+  for (i = 1; i <= argc && argv[i]; ++i)
+  {
+      if (startswith(argv[i],"--run-real-ref="))
+      {
+          if (sscanf(argv[i]+strlen("--run-real-ref="), "%d", &(params.runRealRef)) != 1) params.runRealRef = 1;
+      }
+  }
+
+//strcpy(params.yamlFileName, optarg);
+
+  for (i = 1; i <= argc && argv[i]; ++i)
+  {
+      if (startswith(argv[i],"--yaml="))
+      {
+          sscanf(argv[i]+strlen("--yaml="), "%s", params.yamlFileName);
+      }
+  }
 
   // Check if --rt was specified on the command line
   int * rt  = iparams+3;  // Assume runtime was not specified and will be read from the hpcg.dat file
   if (! iparams[3]) rt = 0; // If --rt was specified, we already have the runtime, so don't read it from file
   if (! iparams[0] && ! iparams[1] && ! iparams[2]) { /* no geometry arguments on the command line */
-    ReadHpcgDat(iparams, rt, iparams+7);
-    broadcastParams = true;
+    ReadHpcgDat(iparams, rt);
+  }
+
+  int nn = 0;
+  for (i = 1; i <= argc && argv[i]; ++i)
+  {
+      if (startswith(argv[i],"-n"))
+      {
+          sscanf(argv[i]+strlen("-n"), "%d", &nn);
+      }
+  }
+  if ( nn > 0 )
+  {
+      for (i = 0; i < 3; ++i) iparams[i] = nn;
   }
 
   // Check for small or unspecified nx, ny, nz values
@@ -113,9 +153,7 @@ HPCG_Init(int * argc_p, char ** *argv_p, HPCG_Params & params) {
 
 // Broadcast values of iparams to all MPI processes
 #ifndef HPCG_NO_MPI
-  if (broadcastParams) {
-    MPI_Bcast( iparams, nparams, MPI_INT, 0, MPI_COMM_WORLD );
-  }
+  MPI_Bcast( iparams, 4, MPI_INT, 0, MPI_COMM_WORLD );
 #endif
 
   params.nx = iparams[0];
@@ -123,13 +161,6 @@ HPCG_Init(int * argc_p, char ** *argv_p, HPCG_Params & params) {
   params.nz = iparams[2];
 
   params.runningTime = iparams[3];
-  params.pz = iparams[4];
-  params.zl = iparams[5];
-  params.zu = iparams[6];
-
-  params.npx = iparams[7];
-  params.npy = iparams[8];
-  params.npz = iparams[9];
 
 #ifndef HPCG_NO_MPI
   MPI_Comm_rank( MPI_COMM_WORLD, &params.comm_rank );
@@ -145,26 +176,25 @@ HPCG_Init(int * argc_p, char ** *argv_p, HPCG_Params & params) {
   #pragma omp parallel
   params.numThreads = omp_get_num_threads();
 #endif
-//  for (i = 0; i < nparams; ++i) std::cout << "rank = "<< params.comm_rank << " iparam["<<i<<"] = " << iparams[i] << "\n";
 
   time ( &rawtime );
   ptm = localtime(&rawtime);
-  sprintf( fname, "hpcg%04d%02d%02dT%02d%02d%02d.txt",
+  sprintf( fname, "hpcg_log_%04d.%02d.%02d.%02d.%02d.%02d.txt",
       1900 + ptm->tm_year, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec );
 
-  if (0 == params.comm_rank) {
+  if (0 == params.comm_rank)
     HPCG_fout.open(fname);
-  } else {
+  else {
 #if defined(HPCG_DEBUG) || defined(HPCG_DETAILED_DEBUG)
-    sprintf( fname, "hpcg%04d%02d%02dT%02d%02d%02d_%d.txt",
-        1900 + ptm->tm_year, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, params.comm_rank );
+    char local[15];
+    sprintf( local, "%d_", params.comm_rank );
+    sprintf( fname, "hpcg_log_%s%04.d%02d.%02d.%02d.%02d.%02d.txt", local,
+        1900 + ptm->tm_year, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec );
     HPCG_fout.open(fname);
 #else
     HPCG_fout.open(NULLDEVICE);
 #endif
   }
 
-  free( iparams );
-
   return 0;
 }
diff --git a/src/main.cpp b/src/main.cpp
index 8ff7961..77bd8d8 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
@@ -61,6 +74,15 @@ using std::endl;
 #include "TestSymmetry.hpp"
 #include "TestNorms.hpp"
 
+#include <cmath>
+#include <cfloat>
+
+#include <ittnotify.h>
+#include <signal.h>
+#include <stdlib.h>
+#define STARTSDE(go,rank) {if(go && 0==rank && getenv("PCMPID")) kill(atoi(getenv("PCMPID")),SIGUSR1); __itt_resume(); __SSC_MARK(0x111);}
+#define STOPSDE(go,rank) {__SSC_MARK(0x222); __itt_pause(); if(go && 0==rank && getenv("PCMPID")) kill(atoi(getenv("PCMPID")),SIGUSR1);}
+
 /*!
   Main driver program: Construct synthetic problem, run V&V tests, compute benchmark parameters, run benchmark, report results.
 
@@ -119,7 +141,7 @@ int main(int argc, char * argv[]) {
 
   // Construct the geometry and linear system
   Geometry * geom = new Geometry;
-  GenerateGeometry(size, rank, params.numThreads, params.pz, params.zl, params.zu, nx, ny, nz, params.npx, params.npy, params.npz, geom);
+  GenerateGeometry(size, rank, params.numThreads, nx, ny, nz, geom);
 
   ierr = CheckAspectRatio(0.125, geom->npx, geom->npy, geom->npz, "process grid", rank==0);
   if (ierr)
@@ -127,20 +149,20 @@ int main(int argc, char * argv[]) {
 
   // Use this array for collecting timing information
   std::vector< double > times(10,0.0);
-
+  int nproc = MKL_Get_Max_Threads();
   double setup_time = mytimer();
 
   SparseMatrix A;
   InitializeSparseMatrix(A, geom);
-
+  A.nproc = nproc;
   Vector b, x, xexact;
   GenerateProblem(A, &b, &x, &xexact);
   SetupHalo(A);
   int numberOfMgLevels = 4; // Number of levels including first
   SparseMatrix * curLevelMatrix = &A;
   for (int level = 1; level< numberOfMgLevels; ++level) {
-    GenerateCoarseProblem(*curLevelMatrix);
-    curLevelMatrix = curLevelMatrix->Ac; // Make the just-constructed coarse grid the next level
+      GenerateCoarseProblem(*curLevelMatrix);
+      curLevelMatrix = curLevelMatrix->Ac; // Make the just-constructed coarse grid the next level
   }
 
   setup_time = mytimer() - setup_time; // Capture total time of setup
@@ -158,12 +180,19 @@ int main(int argc, char * argv[]) {
      curxexact = 0;
   }
 
+//  if( params.runRealRef == 0 )
+//  {
+      curLevelMatrix = &A;
+      for (int level = 0; level< numberOfMgLevels; ++level)
+      {
+          MKL_free(curLevelMatrix->mtxG);
+          curLevelMatrix = curLevelMatrix->Ac;
+      }
+//  }
 
   CGData data;
   InitializeSparseCGData(A, data);
 
-
-
   ////////////////////////////////////
   // Reference SpMV+MG Timing Phase //
   ////////////////////////////////////
@@ -173,23 +202,25 @@ int main(int argc, char * argv[]) {
   local_int_t nrow = A.localNumberOfRows;
   local_int_t ncol = A.localNumberOfColumns;
 
-  Vector x_overlap, b_computed;
-  InitializeVector(x_overlap, ncol); // Overlapped copy of x vector
-  InitializeVector(b_computed, nrow); // Computed RHS vector
-
-
-  // Record execution time of reference SpMV and MG kernels for reporting times
-  // First load vector with random values
-  FillRandomVector(x_overlap);
-
   int numberOfCalls = 10;
   if (quickPath) numberOfCalls = 1; //QuickPath means we do on one call of each block of repetitive code
   double t_begin = mytimer();
-  for (int i=0; i< numberOfCalls; ++i) {
-    ierr = ComputeSPMV_ref(A, x_overlap, b_computed); // b_computed = A*x_overlap
-    if (ierr) HPCG_fout << "Error in call to SpMV: " << ierr << ".\n" << endl;
-    ierr = ComputeMG_ref(A, b_computed, x_overlap); // b_computed = Minv*y_overlap
-    if (ierr) HPCG_fout << "Error in call to MG: " << ierr << ".\n" << endl;
+  if( params.runRealRef != 0 )
+  {
+      Vector x_overlap, b_computed;
+      InitializeVector(x_overlap, ncol); // Overlapped copy of x vector
+      InitializeVector(b_computed, nrow); // Computed RHS vector
+      // Record execution time of reference SpMV and MG kernels for reporting times
+      // First load vector with random values
+      FillRandomVector(x_overlap);
+        for (int i=0; i< numberOfCalls; ++i) {
+          ierr = ComputeSPMV_ref(A, x_overlap, b_computed); // b_computed = A*x_overlap
+          if (ierr) HPCG_fout << "Error in call to SpMV: " << ierr << ".\n" << endl;
+          ierr = ComputeMG_ref(A, b_computed, x_overlap); // b_computed = Minv*y_overlap
+          if (ierr) HPCG_fout << "Error in call to MG: " << ierr << ".\n" << endl;
+        }
+      DeleteVector(x_overlap);
+      DeleteVector(b_computed);
   }
   times[8] = (mytimer() - t_begin)/((double) numberOfCalls);  // Total time divided by number of calls.
 #ifdef HPCG_DEBUG
@@ -212,32 +243,49 @@ int main(int argc, char * argv[]) {
   int refMaxIters = 50;
   numberOfCalls = 1; // Only need to run the residual reduction analysis once
 
-  // Compute the residual reduction for the natural ordering and reference kernels
   std::vector< double > ref_times(9,0.0);
   double tolerance = 0.0; // Set tolerance to zero to make all runs do maxIters iterations
   int err_count = 0;
-  for (int i=0; i< numberOfCalls; ++i) {
-    ZeroVector(x);
-    ierr = CG_ref( A, data, b, x, refMaxIters, tolerance, niters, normr, normr0, &ref_times[0], true);
-    if (ierr) ++err_count; // count the number of errors in CG
-    totalNiters_ref += niters;
+  double refTolerance = 0.0;
+
+  if( params.runRealRef == 0 )
+  {
+      // Call user-tunable set up function.
+      double t7 = 0.0;
+      OptimizeProblem(&A, t7);
+      times[7] = t7;
+      // Compute the residual reduction for the natural ordering and reference kernels
+      for (int i=0; i< numberOfCalls; ++i)
+      {
+          ZeroVector(x);
+          ierr = CG    ( A, data, b, x, refMaxIters, tolerance, niters, normr, normr0, &ref_times[0], true);
+          if (ierr) ++err_count; // count the number of errors in CG
+          totalNiters_ref += niters;
+      }
+  } else
+  {
+      // Compute the residual reduction for the natural ordering and reference kernels
+      for (int i=0; i< numberOfCalls; ++i)
+      {
+          ZeroVector(x);
+          ierr = CG_ref( A, data, b, x, refMaxIters, tolerance, niters, normr, normr0, &ref_times[0], true);
+          if (ierr) ++err_count; // count the number of errors in CG
+          totalNiters_ref += niters;
+      }
+      // Call user-tunable set up function.
+      double t7 = 0.0;
+      OptimizeProblem(&A, t7);
+      times[7] = t7;
   }
-  if (rank == 0 && err_count) HPCG_fout << err_count << " error(s) in call(s) to reference CG." << endl;
-  double refTolerance = normr / normr0;
-
-  // Call user-tunable set up function.
-  double t7 = mytimer();
-  OptimizeProblem(A, data, b, x, xexact);
-  t7 = mytimer() - t7;
-  times[7] = t7;
 #ifdef HPCG_DEBUG
   if (rank==0) HPCG_fout << "Total problem setup time in main (sec) = " << mytimer() - t1 << endl;
 #endif
-
 #ifdef HPCG_DETAILED_DEBUG
   if (geom->size == 1) WriteProblem(*geom, A, b, x, xexact);
 #endif
 
+  if (rank == 0 && err_count) HPCG_fout << err_count << " error(s) in call(s) to reference CG." << endl;
+  refTolerance = normr / normr0;
 
   //////////////////////////////
   // Validation Testing Phase //
@@ -283,7 +331,9 @@ int main(int argc, char * argv[]) {
     double last_cummulative_time = opt_times[0];
     ierr = CG( A, data, b, x, optMaxIters, refTolerance, niters, normr, normr0, &opt_times[0], true);
     if (ierr) ++err_count; // count the number of errors in CG
-    if (normr / normr0 > refTolerance) ++tolerance_failures; // the number of failures to reduce residual
+//    if (normr / normr0 >= refTolerance) ++tolerance_failures; // the number of failures to reduce residual
+    double ff = normr/normr0-refTolerance;
+    if (ff >= DBL_EPSILON) ++tolerance_failures; // the number of failures to reduce residual
 
     // pick the largest number of iterations to guarantee convergence
     if (niters > optNiters) optNiters = niters;
@@ -298,7 +348,6 @@ int main(int argc, char * argv[]) {
   MPI_Allreduce(&local_opt_worst_time, &opt_worst_time, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
 #endif
 
-
   if (rank == 0 && err_count) HPCG_fout << err_count << " error(s) in call(s) to optimized CG." << endl;
   if (tolerance_failures) {
     global_failure = 1;
@@ -331,13 +380,17 @@ int main(int argc, char * argv[]) {
   testnorms_data.samples = numberOfCgSets;
   testnorms_data.values = new double[numberOfCgSets];
 
+STARTSDE(1,rank);
   for (int i=0; i< numberOfCgSets; ++i) {
     ZeroVector(x); // Zero out x
+    MPI_Barrier(MPI_COMM_WORLD);
     ierr = CG( A, data, b, x, optMaxIters, optTolerance, niters, normr, normr0, &times[0], true);
     if (ierr) HPCG_fout << "Error in call to CG: " << ierr << ".\n" << endl;
     if (rank==0) HPCG_fout << "Call [" << i << "] Scaled Residual [" << normr/normr0 << "]" << endl;
     testnorms_data.values[i] = normr/normr0; // Record scaled residual from this run
   }
+STOPSDE(1,rank);
+if (rank==0) printf("Walltime of the main kernel: %.6lf sec\n", times[0]);
 
   // Compute difference between known exact solution and computed solution
   // All processors are needed here.
@@ -356,7 +409,7 @@ int main(int argc, char * argv[]) {
   ////////////////////
 
   // Report results to YAML file
-  ReportResults(A, numberOfMgLevels, numberOfCgSets, refMaxIters, optMaxIters, &times[0], testcg_data, testsymmetry_data, testnorms_data, global_failure, quickPath);
+  ReportResults(A, numberOfMgLevels, numberOfCgSets, refMaxIters, optMaxIters, &times[0], testcg_data, testsymmetry_data, testnorms_data, global_failure, quickPath, params);
 
   // Clean up
   DeleteMatrix(A); // This delete will recursively delete all coarse grid data
@@ -364,14 +417,9 @@ int main(int argc, char * argv[]) {
   DeleteVector(x);
   DeleteVector(b);
   DeleteVector(xexact);
-  DeleteVector(x_overlap);
-  DeleteVector(b_computed);
   delete [] testnorms_data.values;
 
-
-
   HPCG_Finalize();
-
   // Finish up
 #ifndef HPCG_NO_MPI
   MPI_Finalize();
diff --git a/src/mpi_hpcg_api.hpp b/src/mpi_hpcg_api.hpp
new file mode 100644
index 0000000..44b81f6
--- /dev/null
+++ b/src/mpi_hpcg_api.hpp
@@ -0,0 +1,129 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
+
+#ifndef HPCG_MPI_API_HPP
+#define HPCG_MPI_API_HPP
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef int HPCG_MPI_Comm;
+typedef int HPCG_MPI_Datatype;
+typedef int HPCG_MPI_Op;
+
+/* Enough bits to hold a pointer */
+typedef uintptr_t HPCG_MPI_Request;
+
+/* BUGBUGBUG: The fields below are never marshalled */
+typedef struct HPCG_MPI_Status {
+	int count;
+	int cancelled;
+	int HPCG_MPI_SOURCE;
+	int HPCG_MPI_TAG;
+	int HPCG_MPI_ERROR;
+	char filler[64];
+} HPCG_MPI_Status;
+
+/* (Some) MPI constants */
+extern int HPCG_MPI_ANY_SOURCE;
+
+extern int HPCG_MPI_COMM_NULL;
+extern int HPCG_MPI_COMM_WORLD;
+extern int HPCG_MPI_MAX_PROCESSOR_NAME;
+
+extern void* HPCG_MPI_IN_PLACE;
+
+extern int HPCG_MPI_CHAR;
+extern int HPCG_MPI_BYTE;
+extern int HPCG_MPI_DOUBLE;
+extern int HPCG_MPI_DOUBLE_INT;
+extern int HPCG_MPI_DOUBLE_PRECISION;
+extern int HPCG_MPI_FLOAT;
+extern int HPCG_MPI_LONG_LONG_INT;
+extern int HPCG_MPI_SCALAPACK_INT;
+
+extern int HPCG_MPI_MAXLOC;
+extern int HPCG_MPI_MAX;
+extern int HPCG_MPI_MIN;
+extern int HPCG_MPI_SUM;
+
+extern HPCG_MPI_Request HPCG_MPI_REQUEST_NULL;
+extern HPCG_MPI_Status* HPCG_MPI_STATUSES_IGNORE;
+extern HPCG_MPI_Status* HPCG_MPI_STATUS_IGNORE;
+
+extern int HPCG_MPI_SIMILAR;
+extern int HPCG_MPI_SUCCESS;
+extern int HPCG_MPI_UNDEFINED;
+
+/* (Some) MPI functions */
+int HPCG_MPI_Initmpi(int *argc, char ***argv);
+int HPCG_MPI_Finalize();
+int HPCG_MPI_Get_processor_name(char *name, int *resultlen);
+double HPCG_MPI_Wtime();
+
+int HPCG_MPI_Comm_rank(HPCG_MPI_Comm comm, int *rank);
+int HPCG_MPI_Comm_size(HPCG_MPI_Comm comm, int *size);
+int HPCG_MPI_Request_free(HPCG_MPI_Request *request);
+
+int HPCG_MPI_Send(void *buf, int count, HPCG_MPI_Datatype datatype,
+		int dest, int tag, HPCG_MPI_Comm comm);
+int HPCG_MPI_Irecv(void *buf, int count, HPCG_MPI_Datatype datatype,
+		int source, int tag, HPCG_MPI_Comm comm, HPCG_MPI_Request *request);
+int HPCG_MPI_Bcast(void *buffer, int count, HPCG_MPI_Datatype datatype,
+		int root, HPCG_MPI_Comm comm);
+
+int HPCG_MPI_Wait(HPCG_MPI_Request *request, HPCG_MPI_Status *status);
+int HPCG_MPI_Barrier(HPCG_MPI_Comm comm);
+int HPCG_MPI_Waitall(int count,
+		HPCG_MPI_Request *requests, HPCG_MPI_Status *statuses);
+
+int HPCG_MPI_Allreduce(void *sendbuf, void *recvbuf, int count,
+		HPCG_MPI_Datatype datatype, HPCG_MPI_Op op, HPCG_MPI_Comm comm);
+int HPCG_MPI_Allgather(void *sendbuf, int sendcount, HPCG_MPI_Datatype sendtype,
+		void *recvbuf, int recvcount, HPCG_MPI_Datatype recvtype,
+		HPCG_MPI_Comm comm);
+
+int HPCG_MPI_Recv_init(void *buf, int count, HPCG_MPI_Datatype datatype,
+		int source ,int tag, HPCG_MPI_Comm comm, HPCG_MPI_Request *request);
+int HPCG_MPI_Send_init(void *buf, int count, HPCG_MPI_Datatype datatype,
+		int dest, int tag, HPCG_MPI_Comm comm, HPCG_MPI_Request *request);
+int HPCG_MPI_Startall(int a, HPCG_MPI_Request *requests);
+
+int HPCG_MPI_Error_string(int errorcode, char *string, int *resultlen);
+
+int HPCG_MPI_Gather(void *sendbuf, int sendcount, HPCG_MPI_Datatype sendtype,
+        void *recvbuf, int recvcount, HPCG_MPI_Datatype recvtype,
+        int root, HPCG_MPI_Comm comm);
+
+int HPCG_MPI_Test(HPCG_MPI_Request *request, int *flag, HPCG_MPI_Status *status);
+
+int HPCG_MPI_Cancel(HPCG_MPI_Request *request);
+
+int HPCG_MPI_Abort(HPCG_MPI_Comm comm, int errorcode);
+
+int HPCG_MPI_Testany(int count, HPCG_MPI_Request array_of_requests[], int *indx,
+               int *flag, HPCG_MPI_Status *status);
+
+int HPCG_MPI_Iallreduce(void *sendbuf, void *recvbuf, int count,
+        HPCG_MPI_Datatype datatype, HPCG_MPI_Op op, HPCG_MPI_Comm comm,
+        HPCG_MPI_Request *hpcg_mpi_request);
+
+#ifdef __cplusplus
+}
+#endif
+#endif // HPCG_MPI_API_HPP
+
diff --git a/src/mpi_wrappers.cpp b/src/mpi_wrappers.cpp
new file mode 100644
index 0000000..22b8285
--- /dev/null
+++ b/src/mpi_wrappers.cpp
@@ -0,0 +1,523 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
+
+#include <assert.h>
+#include <stdlib.h>
+
+#include "mpi_hpcg_api.hpp"
+#include "mpi.h"
+
+/* Comment the next define out to disable forced cancellation of outstanding
+ * requests in HPCG_MPI_Request_free() */
+#define _HPCG_MPI_REQUEST_FREE_CANCEL_OUTSTANDING_REQUESTS
+
+#ifdef _OPENMPI
+
+/* OpenMPI (and maybe other MPIs) needs additional marshalling of the values.
+ * We create dummy values here and do the marshalling in the HPCG_MPI2MPI_*()
+ * functions. */
+
+enum {
+	_MPI_COMM_NULL = 2,
+	_MPI_COMM_WORLD,
+	_MPI_BYTE,
+	_MPI_DOUBLE,
+	_MPI_DOUBLE_INT,
+	_MPI_DOUBLE_PRECISION,
+	_MPI_FLOAT,
+	_MPI_LONG_LONG_INT,
+	_MPI_INT,
+	_MPI_MAX,
+	_MPI_MAXLOC,
+	_MPI_MIN,
+	_MPI_SUM,
+	_MPI_CHAR,
+};
+
+#define HPCG_MPI2MPI_CONST(name) case (- _MPI_##name) : return MPI_##name
+#define WRAP_MPI_CONST(name) (- _ ## name)
+
+#else
+
+#define WRAP_MPI_CONST(name) name
+
+#endif
+
+int HPCG_MPI_ANY_SOURCE = MPI_ANY_SOURCE;
+int HPCG_MPI_MAX_PROCESSOR_NAME = MPI_MAX_PROCESSOR_NAME;
+
+int HPCG_MPI_COMM_NULL = WRAP_MPI_CONST(MPI_COMM_NULL);
+int HPCG_MPI_COMM_WORLD = WRAP_MPI_CONST(MPI_COMM_WORLD);
+
+int HPCG_MPI_CHAR = WRAP_MPI_CONST(MPI_CHAR);
+int HPCG_MPI_BYTE = WRAP_MPI_CONST(MPI_BYTE);
+int HPCG_MPI_DOUBLE = WRAP_MPI_CONST(MPI_DOUBLE);
+int HPCG_MPI_DOUBLE_INT = WRAP_MPI_CONST(MPI_DOUBLE_INT);
+int HPCG_MPI_DOUBLE_PRECISION = WRAP_MPI_CONST(MPI_DOUBLE_PRECISION);
+int HPCG_MPI_FLOAT = WRAP_MPI_CONST(MPI_FLOAT);
+int HPCG_MPI_LONG_LONG_INT = WRAP_MPI_CONST(MPI_LONG_LONG_INT);
+int HPCG_MPI_SCALAPACK_INT = WRAP_MPI_CONST(MPI_INT);
+
+int HPCG_MPI_MAX = WRAP_MPI_CONST(MPI_MAX);
+int HPCG_MPI_MAXLOC = WRAP_MPI_CONST(MPI_MAXLOC);
+int HPCG_MPI_MIN = WRAP_MPI_CONST(MPI_MIN);
+int HPCG_MPI_SUM = WRAP_MPI_CONST(MPI_SUM);
+
+void *HPCG_MPI_IN_PLACE = (void *)MPI_IN_PLACE;
+
+HPCG_MPI_Request HPCG_MPI_REQUEST_NULL = (HPCG_MPI_Request)MPI_REQUEST_NULL;
+HPCG_MPI_Status *HPCG_MPI_STATUSES_IGNORE = (HPCG_MPI_Status *)MPI_STATUSES_IGNORE;
+HPCG_MPI_Status *HPCG_MPI_STATUS_IGNORE = (HPCG_MPI_Status *)MPI_STATUS_IGNORE;
+
+int HPCG_MPI_SIMILAR = MPI_SIMILAR;
+int HPCG_MPI_SUCCESS = MPI_SUCCESS;
+int HPCG_MPI_UNDEFINED = MPI_UNDEFINED;
+
+/* Utils */
+static inline void *HPCG_MPI2MPI_Alloc(size_t len)
+{
+	if (!len) return NULL;
+	void *ptr = malloc(len);
+	if (ptr == NULL) abort();
+	return ptr;
+}
+
+static inline void HPCG_MPI2MPI_Free(void *ptr)
+{
+	free(ptr);
+}
+
+#define HPCG_MPI2MPI_Copy_in(dst, src, count, type) do { \
+	for (int i = 0; i < count; i++) \
+		dst[i] = *((type *)(src + i)); \
+} while (0)
+
+#define HPCG_MPI2MPI_Copy_out(dst, src, count, type) do { \
+	for (int i = 0; i < count; i++) \
+		*((type *)(dst + i)) = src[i]; \
+} while (0)
+
+static inline MPI_Request *HPCG_MPI2MPI_Requests_copy_in(int count,
+		HPCG_MPI_Request *hpcg_mpi_requests)
+{
+	MPI_Request *mpi_requests;
+	assert(sizeof(MPI_Request) <= sizeof(HPCG_MPI_Request));
+
+	if (sizeof(MPI_Request) == sizeof(HPCG_MPI_Request))
+		mpi_requests = (MPI_Request *)hpcg_mpi_requests;
+	else {
+		mpi_requests =
+			(MPI_Request *)HPCG_MPI2MPI_Alloc(sizeof(MPI_Request) * count);
+		HPCG_MPI2MPI_Copy_in(mpi_requests,
+				hpcg_mpi_requests, count, MPI_Request);
+	}
+
+	return mpi_requests;
+}
+
+static inline void HPCG_MPI2MPI_Requests_copy_out(int count,
+		HPCG_MPI_Request *hpcg_mpi_requests, MPI_Request *mpi_requests)
+{
+	if (sizeof(MPI_Request) != sizeof(HPCG_MPI_Request)) {
+		HPCG_MPI2MPI_Copy_out(hpcg_mpi_requests,
+				mpi_requests, count, MPI_Request);
+		HPCG_MPI2MPI_Free(mpi_requests);
+	}
+}
+
+static inline void HPCG_MPI2MPI_Request_copy_in(MPI_Request *mpi_request,
+		HPCG_MPI_Request *hpcg_mpi_request)
+{
+	HPCG_MPI2MPI_Copy_in(mpi_request, hpcg_mpi_request, 1, MPI_Request);
+}
+
+static inline void HPCG_MPI2MPI_Request_copy_out(
+		HPCG_MPI_Request *hpcg_mpi_request, MPI_Request *mpi_request)
+{
+	HPCG_MPI2MPI_Copy_out(hpcg_mpi_request, mpi_request, 1, MPI_Request);
+}
+
+static inline MPI_Status *HPCG_MPI2MPI_Statuses_copy_in(int count,
+		HPCG_MPI_Status *hpcg_mpi_statuses)
+{
+	MPI_Status *mpi_statuses;
+	assert(sizeof(MPI_Status) <= sizeof(HPCG_MPI_Status));
+
+	if (sizeof(MPI_Status) == sizeof(HPCG_MPI_Status))
+		mpi_statuses = (MPI_Status *)hpcg_mpi_statuses;
+	else if (hpcg_mpi_statuses == HPCG_MPI_STATUSES_IGNORE)
+		mpi_statuses = MPI_STATUSES_IGNORE;
+	else {
+		mpi_statuses =
+			(MPI_Status *)HPCG_MPI2MPI_Alloc(sizeof(MPI_Status) * count);
+		HPCG_MPI2MPI_Copy_in(mpi_statuses,
+				hpcg_mpi_statuses, count, MPI_Status);
+	}
+
+	return mpi_statuses;
+}
+
+static inline void HPCG_MPI2MPI_Statuses_copy_out(int count,
+		HPCG_MPI_Status *hpcg_mpi_statuses, MPI_Status *mpi_statuses)
+{
+	if (sizeof(MPI_Status) != sizeof(HPCG_MPI_Status)
+			&& mpi_statuses != MPI_STATUSES_IGNORE)
+	{
+		HPCG_MPI2MPI_Copy_out(hpcg_mpi_statuses,
+				mpi_statuses, count, MPI_Status);
+		HPCG_MPI2MPI_Free(mpi_statuses);
+	} else if (mpi_statuses == MPI_STATUSES_IGNORE)
+		hpcg_mpi_statuses = HPCG_MPI_STATUSES_IGNORE;
+}
+
+static inline void HPCG_MPI2MPI_Status_copy_in(MPI_Status *mpi_status,
+		HPCG_MPI_Status *hpcg_mpi_status)
+{
+	HPCG_MPI2MPI_Copy_in(mpi_status, hpcg_mpi_status, 1, MPI_Status);
+}
+
+static inline void HPCG_MPI2MPI_Status_copy_out(
+		HPCG_MPI_Status *hpcg_mpi_status, MPI_Status *mpi_status)
+{
+	HPCG_MPI2MPI_Copy_out(hpcg_mpi_status, mpi_status, 1, MPI_Status);
+}
+
+static inline MPI_Comm HPCG_MPI2MPI_Comm(HPCG_MPI_Comm comm)
+{
+#ifdef _OPENMPI
+	switch (comm) {
+		HPCG_MPI2MPI_CONST(COMM_WORLD);
+		HPCG_MPI2MPI_CONST(COMM_NULL);
+	}
+	assert(!"Unknown HPCG_MPI_Comm!");
+#else
+	/* XXX: we might still want to check that the comm is valid. */
+	return comm;
+#endif
+}
+
+static inline MPI_Datatype HPCG_MPI2MPI_Datatype(HPCG_MPI_Datatype type)
+{
+#ifdef _OPENMPI
+	switch (type) {
+		HPCG_MPI2MPI_CONST(CHAR);
+		HPCG_MPI2MPI_CONST(BYTE);
+		HPCG_MPI2MPI_CONST(DOUBLE);
+		HPCG_MPI2MPI_CONST(DOUBLE_INT);
+		HPCG_MPI2MPI_CONST(DOUBLE_PRECISION);
+		HPCG_MPI2MPI_CONST(FLOAT);
+		HPCG_MPI2MPI_CONST(INT);
+		HPCG_MPI2MPI_CONST(LONG_LONG_INT);
+	}
+	assert(!"Unknown HPCG_MPI_Datatype!");
+	return MPI_DATATYPE_NULL;
+#else
+	/* XXX: we might still want to check that the type is valid. */
+	return type;
+#endif
+}
+
+static inline MPI_Op HPCG_MPI2MPI_Op(HPCG_MPI_Op op)
+{
+#ifdef _OPENMPI
+	switch (op) {
+		HPCG_MPI2MPI_CONST(MAXLOC);
+		HPCG_MPI2MPI_CONST(MAX);
+		HPCG_MPI2MPI_CONST(MIN);
+		HPCG_MPI2MPI_CONST(SUM);
+	}
+	/* XXX: we might still want to check that the op is valid. */
+	assert(!"Unknown HPCG_MPI_Op!");
+#else
+	return op;
+#endif
+}
+
+static inline int HPCG_MPI2MPI_Tag(int tag)
+{
+	/* XXX: we might still want to check that the op is valid and check for
+	 * MPI_TAG_ANY. */
+	return tag;
+}
+
+static inline int HPCG_MPI2MPI_Root(int root)
+{
+	/* XXX: we might still want to check that the op is valid and check for
+	 * MPI_PROC_NULL and MPI_ROOT. */
+	return root;
+}
+
+/* XXX: we also may need HPCG_MPI2MPI_Send_buf(void *buf) that would check for
+ * MPI_IN_PLACE and MPI_BOTTOM. */
+
+static inline int HPCG_MPI2MPI_Source(int source)
+{
+#ifdef _OPENMPI
+	return (source == HPCG_MPI_ANY_SOURCE) ? MPI_ANY_SOURCE : source;
+#else
+	return source;
+#endif
+}
+
+/* MPI wrappers */
+
+int HPCG_MPI_Wait(HPCG_MPI_Request *hpcg_mpi_request,
+		HPCG_MPI_Status *hpcg_mpi_status)
+{
+	MPI_Request mpi_request;
+	HPCG_MPI2MPI_Request_copy_in(&mpi_request, hpcg_mpi_request);
+	MPI_Status *mpi_status = HPCG_MPI2MPI_Statuses_copy_in(1, hpcg_mpi_status);
+	int ierror = MPI_Wait(&mpi_request, mpi_status);
+	HPCG_MPI2MPI_Statuses_copy_out(1, hpcg_mpi_status, mpi_status);
+	if (mpi_request == MPI_REQUEST_NULL)
+		*hpcg_mpi_request = HPCG_MPI_REQUEST_NULL;
+	else
+		HPCG_MPI2MPI_Request_copy_out(hpcg_mpi_request, &mpi_request);
+	return ierror;
+}
+
+int HPCG_MPI_Request_free(HPCG_MPI_Request *hpcg_mpi_request)
+{
+	MPI_Request mpi_request;
+	HPCG_MPI2MPI_Request_copy_in(&mpi_request, hpcg_mpi_request);
+#ifdef _HPCG_MPI_REQUEST_FREE_CANCEL_OUTSTANDING_REQUESTS
+	/* This hack is required for e.g. SGI MPT which hangs in MPI_Finalize() if
+	 * there are outstanding recv requests. These requests originate from e.g.
+	 * halo exchange code that eagerly posts recv requests for the next
+	 * exchange after the current one is complete. Since the next one may or
+	 * may not happen, the last eager recv requests remain outstanding forever.
+	 *
+	 * We cannot MPI_Wait() for such recv requests here because they have no
+	 * matching send requests, so we just cancel and carry on.
+	 *
+	 * The side effect is that ierror handling is borken. */
+	int ierror, flag;
+	ierror = MPI_Test(&mpi_request, &flag, MPI_STATUS_IGNORE);
+	if (ierror != MPI_SUCCESS)
+		return ierror;
+	if (!flag) {
+		ierror = MPI_Cancel(&mpi_request);
+		if (ierror != MPI_SUCCESS)
+			return ierror;
+	}
+	ierror = MPI_Request_free(&mpi_request);
+#else
+	int ierror = MPI_Request_free(&mpi_request);
+#endif
+	if (mpi_request == MPI_REQUEST_NULL)
+		*hpcg_mpi_request = HPCG_MPI_REQUEST_NULL;
+	else
+		HPCG_MPI2MPI_Request_copy_out(hpcg_mpi_request, &mpi_request);
+	return ierror;
+}
+
+double HPCG_MPI_Wtime()
+{
+	return MPI_Wtime();
+}
+
+int HPCG_MPI_Finalize()
+{
+	return MPI_Finalize();
+}
+
+int HPCG_MPI_Initmpi(int *argc, char ***argv)
+{
+#ifdef _USE_THREADED_MPI
+	int required = MPI_THREAD_MULTIPLE, provided, rc;
+	rc = MPI_Init_thread(argc, argv, required, &provided);
+	if (provided != required)
+		abort();
+	return rc;
+#else
+	return MPI_Init(argc, argv);
+#endif
+}
+
+int HPCG_MPI_Get_processor_name(char *name, int *resultlen)
+{
+	return MPI_Get_processor_name(name, resultlen);
+}
+
+int HPCG_MPI_Error_string(int errorcode, char *string, int *resultlen)
+{
+	return MPI_Error_string(errorcode, string, resultlen);
+}
+
+int HPCG_MPI_Gather(void *sendbuf, int sendcount, HPCG_MPI_Datatype sendtype,
+               void *recvbuf, int recvcount, HPCG_MPI_Datatype recvtype,
+                              int root, HPCG_MPI_Comm comm)
+{
+    return MPI_Gather(sendbuf, sendcount, HPCG_MPI2MPI_Datatype(sendtype), recvbuf, recvcount, HPCG_MPI2MPI_Datatype(recvtype), root, HPCG_MPI2MPI_Comm(comm));
+}
+
+int HPCG_MPI_Irecv(void* buf, int count, HPCG_MPI_Datatype datatype,
+		int source, int tag, HPCG_MPI_Comm comm,
+		HPCG_MPI_Request *hpcg_mpi_request)
+{
+	MPI_Request mpi_request;
+	HPCG_MPI2MPI_Request_copy_in(&mpi_request, hpcg_mpi_request);
+	int ierror = MPI_Irecv(buf, count, HPCG_MPI2MPI_Datatype(datatype), source,
+			HPCG_MPI2MPI_Tag(tag), HPCG_MPI2MPI_Comm(comm), &mpi_request);
+	HPCG_MPI2MPI_Request_copy_out(hpcg_mpi_request, &mpi_request);
+	return ierror;
+}
+
+int HPCG_MPI_Barrier(HPCG_MPI_Comm comm)
+{
+	return MPI_Barrier(HPCG_MPI2MPI_Comm(comm));
+}
+
+int HPCG_MPI_Comm_rank(HPCG_MPI_Comm comm, int *rank)
+{
+	return MPI_Comm_rank(HPCG_MPI2MPI_Comm(comm), rank);
+}
+
+int HPCG_MPI_Comm_size(HPCG_MPI_Comm comm, int *size)
+{
+	return MPI_Comm_size(HPCG_MPI2MPI_Comm(comm), size);
+}
+
+int HPCG_MPI_Bcast(void *buffer, int count, HPCG_MPI_Datatype datatype,
+		int root, HPCG_MPI_Comm comm)
+{
+	return MPI_Bcast(buffer, count, HPCG_MPI2MPI_Datatype(datatype),
+			HPCG_MPI2MPI_Root(root), HPCG_MPI2MPI_Comm(comm));
+}
+
+int HPCG_MPI_Send(void *buf, int count, HPCG_MPI_Datatype datatype,
+		int dest, int tag, HPCG_MPI_Comm comm)
+{
+	return MPI_Send(buf, count, HPCG_MPI2MPI_Datatype(datatype),
+			dest, HPCG_MPI2MPI_Tag(tag), HPCG_MPI2MPI_Comm(comm));
+}
+
+int HPCG_MPI_Startall(int count, HPCG_MPI_Request *hpcg_mpi_requests)
+{
+	MPI_Request *mpi_requests = HPCG_MPI2MPI_Requests_copy_in(count,
+			hpcg_mpi_requests);
+	int ierror = MPI_Startall(count, mpi_requests);
+	HPCG_MPI2MPI_Requests_copy_out(count, hpcg_mpi_requests, mpi_requests);
+	return ierror;
+}
+
+int HPCG_MPI_Waitall(int count, HPCG_MPI_Request *hpcg_mpi_requests,
+		HPCG_MPI_Status* hpcg_mpi_statuses)
+{
+	MPI_Request *mpi_requests = HPCG_MPI2MPI_Requests_copy_in(count,
+			hpcg_mpi_requests);
+	MPI_Status *mpi_statuses = HPCG_MPI2MPI_Statuses_copy_in(count,
+			hpcg_mpi_statuses);
+	int ierror = MPI_Waitall(count, mpi_requests, mpi_statuses);
+	HPCG_MPI2MPI_Statuses_copy_out(count, hpcg_mpi_statuses, mpi_statuses);
+	HPCG_MPI2MPI_Requests_copy_out(count, hpcg_mpi_requests, mpi_requests);
+	return ierror;
+}
+
+int HPCG_MPI_Allreduce(void *sendbuf, void *recvbuf,
+		int count, HPCG_MPI_Datatype datatype, HPCG_MPI_Op op,
+		HPCG_MPI_Comm comm)
+{
+	return MPI_Allreduce(sendbuf, recvbuf, count,
+			HPCG_MPI2MPI_Datatype(datatype), HPCG_MPI2MPI_Op(op),
+			HPCG_MPI2MPI_Comm(comm));
+}
+
+int HPCG_MPI_Allgather(void *sendbuf, int sendcount, HPCG_MPI_Datatype sendtype,
+		void *recvbuf, int recvcount, HPCG_MPI_Datatype recvtype,
+		HPCG_MPI_Comm comm)
+{
+	/* No need to translate MPI_IN_PLACE because the wrapper value also has a
+	 * pointer type */
+	return MPI_Allgather(sendbuf, sendcount, HPCG_MPI2MPI_Datatype(sendtype),
+			recvbuf, recvcount, HPCG_MPI2MPI_Datatype(recvtype),
+			HPCG_MPI2MPI_Comm(comm));
+}
+
+int HPCG_MPI_Recv_init(void* buf, int count, HPCG_MPI_Datatype datatype,
+		int source, int tag, HPCG_MPI_Comm comm,
+		HPCG_MPI_Request *hpcg_mpi_request)
+{
+	MPI_Request mpi_request;
+	HPCG_MPI2MPI_Request_copy_in(&mpi_request, hpcg_mpi_request);
+	int ierror = MPI_Recv_init(buf, count, HPCG_MPI2MPI_Datatype(datatype),
+			HPCG_MPI2MPI_Source(source), HPCG_MPI2MPI_Tag(tag),
+			HPCG_MPI2MPI_Comm(comm), &mpi_request);
+	HPCG_MPI2MPI_Request_copy_out(hpcg_mpi_request, &mpi_request);
+	return ierror;
+}
+
+int HPCG_MPI_Send_init(void* buf, int count, HPCG_MPI_Datatype datatype,
+		int dest ,int tag, HPCG_MPI_Comm comm,
+		HPCG_MPI_Request *hpcg_mpi_request)
+{
+	MPI_Request mpi_request;
+	HPCG_MPI2MPI_Request_copy_in(&mpi_request, hpcg_mpi_request);
+	int ierror = MPI_Send_init(buf, count, HPCG_MPI2MPI_Datatype(datatype),
+			dest, tag, HPCG_MPI2MPI_Comm(comm), &mpi_request);
+	HPCG_MPI2MPI_Request_copy_out(hpcg_mpi_request, &mpi_request);
+	return ierror;
+}
+
+
+int HPCG_MPI_Test(HPCG_MPI_Request *hpcg_mpi_request, int *flag, HPCG_MPI_Status *hpcg_mpi_status)
+{
+	MPI_Request mpi_request;
+	HPCG_MPI2MPI_Request_copy_in(&mpi_request, hpcg_mpi_request);
+	MPI_Status *mpi_status = HPCG_MPI2MPI_Statuses_copy_in(1, hpcg_mpi_status);
+	int ierror = MPI_Test(&mpi_request, flag, mpi_status);
+	HPCG_MPI2MPI_Statuses_copy_out(1, hpcg_mpi_status, mpi_status);
+	HPCG_MPI2MPI_Request_copy_out(hpcg_mpi_request, &mpi_request);
+	return ierror;
+}
+
+int HPCG_MPI_Cancel(HPCG_MPI_Request *hpcg_mpi_request)
+{
+	MPI_Request mpi_request;
+	HPCG_MPI2MPI_Request_copy_in(&mpi_request, hpcg_mpi_request);
+    int ierror = MPI_Cancel(&mpi_request);
+	HPCG_MPI2MPI_Request_copy_out(hpcg_mpi_request, &mpi_request);
+    return ierror;
+}
+
+int HPCG_MPI_Abort(HPCG_MPI_Comm comm, int errorcode) {
+    return MPI_Abort(HPCG_MPI2MPI_Comm(comm), errorcode);
+}
+
+
+int HPCG_MPI_Testany(int count, HPCG_MPI_Request *hpcg_mpi_requests, int *indx,
+               int *flag, HPCG_MPI_Status *hpcg_mpi_statuses) {
+    MPI_Request *mpi_requests = HPCG_MPI2MPI_Requests_copy_in(count,
+            hpcg_mpi_requests);
+    MPI_Status *mpi_statuses = HPCG_MPI2MPI_Statuses_copy_in(count,
+            hpcg_mpi_statuses);
+    int ierror = MPI_Testany(count, mpi_requests, indx, flag, mpi_statuses);
+    HPCG_MPI2MPI_Statuses_copy_out(count, hpcg_mpi_statuses, mpi_statuses);
+    HPCG_MPI2MPI_Requests_copy_out(count, hpcg_mpi_requests, mpi_requests);
+    return ierror;
+}
+
+int HPCG_MPI_Iallreduce(void *sendbuf, void *recvbuf, int count,
+        HPCG_MPI_Datatype datatype, HPCG_MPI_Op op, HPCG_MPI_Comm comm,
+        HPCG_MPI_Request *hpcg_mpi_request) {
+	MPI_Request mpi_request;
+	HPCG_MPI2MPI_Request_copy_in(&mpi_request, hpcg_mpi_request);
+    int ierror = MPI_Iallreduce(
+        sendbuf, recvbuf, count, HPCG_MPI2MPI_Datatype(datatype), HPCG_MPI2MPI_Op(op), HPCG_MPI2MPI_Comm(comm),
+        &mpi_request);
+	HPCG_MPI2MPI_Request_copy_out(hpcg_mpi_request, &mpi_request);
+    return ierror;
+}
+
+
diff --git a/src/mytimer.cpp b/src/mytimer.cpp
index 1eb8c9d..e69b019 100644
--- a/src/mytimer.cpp
+++ b/src/mytimer.cpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
diff --git a/src/mytimer.hpp b/src/mytimer.hpp
index 73944c0..9f4912d 100644
--- a/src/mytimer.hpp
+++ b/src/mytimer.hpp
@@ -1,3 +1,16 @@
+/*******************************************************************************
+* Copyright 2014-2018 Intel Corporation.
+*
+* This software and the related documents are Intel copyrighted  materials,  and
+* your use of  them is  governed by the  express license  under which  they were
+* provided to you (License).  Unless the License provides otherwise, you may not
+* use, modify, copy, publish, distribute,  disclose or transmit this software or
+* the related documents without Intel's prior written permission.
+*
+* This software and the related documents  are provided as  is,  with no express
+* or implied  warranties,  other  than those  that are  expressly stated  in the
+* License.
+*******************************************************************************/
 
 //@HEADER
 // ***************************************************
-- 
1.8.3.1

